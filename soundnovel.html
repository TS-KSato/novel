<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>銀月の姫と獅子の傭兵</title>
    <style>
        /* Reset CSS */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Variables */
        :root {
            --main-bg-color: #222;
            --text-color: #fff;
            --dialog-bg: rgba(0, 0, 0, 0.7);
            --choice-bg: rgba(50, 50, 70, 0.9);
            --choice-hover: rgba(70, 70, 100, 0.9);
            --menu-bg: rgba(20, 20, 30, 0.95);
            --accent-color: #9c89ff;
            --font-main: 'Helvetica Neue', Arial, sans-serif;
            --title-font: 'Georgia', serif;
            /* Example title font */

            /* Customizable settings */
            --dialog-height: 30vh;
            --transition-duration: 0.5s;
            /* アニメーション時間 */
            --background-transition-duration: 1s;
            /* 背景フェード時間 */
        }

        body {
            font-family: var(--font-main);
            background-color: var(--main-bg-color);
            color: var(--text-color);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            position: relative;
            touch-action: manipulation;
            /* Prevent double-tap zoom */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Loading overlay */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--main-bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            transition: opacity var(--transition-duration) ease;
            opacity: 1;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s infinite linear;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Title Screen */
        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Background URL is now handled by JS for encoding */
            background: var(--main-bg-color) no-repeat center center;
            background-size: cover;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 998;
            /* Below loading, above game */
            opacity: 0;
            /* Hidden initially */
            transition: opacity var(--transition-duration) ease;
            padding: 20px;
            pointer-events: none;
            /* Prevent interaction when hidden */
        }

        #title-screen.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #title-screen h1 {
            font-family: var(--title-font);
            font-size: 3rem;
            color: var(--accent-color);
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .title-button {
            background-color: var(--choice-bg);
            color: var(--text-color);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 15px 30px;
            margin: 10px 0;
            font-size: 1.2rem;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 250px;
            max-width: 80%;
            text-align: center;
        }

        .title-button:hover,
        .title-button:focus {
            background-color: var(--choice-hover);
            outline: none;
        }

        .title-button:active {
            background-color: var(--accent-color);
        }

        /* Title screen load slots area */
        #title-load-slots {
            margin-top: 20px;
            width: 300px;
            max-width: 90%;
            max-height: 40vh;
            /* Limit height */
            overflow-y: auto;
            /* Add scroll if needed */
            background-color: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            display: none;
            /* Hidden initially */
        }

        /* Reuse slot style defined later */
        #title-load-slots .slot {
            margin: 5px 0;
            /* Adjust margin */
            padding: 10px 12px;
            font-size: 0.9rem;
        }

        #title-load-back-button {
            margin-top: 10px;
            /* Reusing .title-button styles, adjusted */
            width: auto;
            font-size: 0.9rem;
            padding: 8px 15px;
        }


        /* Game container - initially hidden */
        #game {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            opacity: 0;
            /* Hidden initially */
            transition: opacity var(--transition-duration) ease;
            pointer-events: none;
            /* Disable interaction when hidden */
        }

        #game.visible {
            opacity: 1;
            pointer-events: auto;
        }


        /* Background */
        #background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-color: var(--main-bg-color);
            /* Default background */
            transition: opacity var(--background-transition-duration) ease;
            background-image: none;
            /* 初期状態は画像なし */
        }

        #background.fade {
            opacity: 0;
        }


        /* Dialog box */
        #dialog-box {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--dialog-height);
            background-color: var(--dialog-bg);
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            /* Changed from none to flex for visibility control */
            flex-direction: column;
            transition: transform var(--transition-duration) ease;
            cursor: pointer;
            /* Default cursor is pointer */
            visibility: visible;
            /* Use visibility for hide/show with game */
        }

        #game:not(.visible) #dialog-box {
            visibility: hidden;
        }


        #speaker {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.2rem;
            color: var(--accent-color);
            min-height: 1.5rem;
            /* Ensure space even if empty */
        }

        #text {
            font-size: 1.1rem;
            line-height: 1.5;
            flex-grow: 1;
            overflow-y: auto;
            word-break: break-word;
            /* Ensure long words break */
            white-space: pre-wrap;
            /* Preserve line breaks from text */
        }

        #next-indicator {
            position: absolute;
            bottom: 15px;
            right: 15px;
            font-size: 1.5rem;
            animation: blink 1s infinite;
            display: none;
            /* Initially hidden */
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 0;
            }

            50% {
                opacity: 1;
            }
        }

        /* Choices container */
        #choices {
            position: absolute;
            bottom: calc(var(--dialog-height) + 10px);
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            display: none;
            /* Initially hidden */
            flex-direction: column;
            padding: 10px;
            gap: 10px;
            z-index: 10;
        }

        /* Choice button */
        .choice {
            background-color: var(--choice-bg);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 15px;
            margin: 0;
            /* Reset margin */
            font-size: 1rem;
            color: var(--text-color);
            cursor: pointer;
            transition: background-color 0.3s;
            text-align: center;
            width: 100%;
            display: block;
            /* Ensure display is block or similar */
        }

        .choice[style*="display: none"] {
            /* Rule to hide buttons set to display:none via JS */
            display: none !important;
        }


        .choice:hover,
        .choice:focus {
            background-color: var(--choice-hover);
            outline: none;
        }

        .choice:active {
            background-color: var(--accent-color);
        }

        /* Menu button */
        #menu-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: var(--dialog-bg);
            color: var(--text-color);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.5rem;
            display: none;
            /* Initially hidden, controlled by JS */
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            transition: background-color 0.3s;
        }

        #game.visible #menu-button {
            display: flex;
            /* Show only when game is visible */
        }


        #menu-button:hover {
            background-color: var(--choice-hover);
        }

        /* Menu container */
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--menu-bg);
            display: none;
            /* Initially hidden */
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 99;
            padding: 60px 20px 20px;
            gap: 15px;
            overflow-y: auto;
            opacity: 0;
            transition: opacity var(--transition-duration) ease;
        }

        #menu.visible {
            opacity: 1;
            display: flex;
            /* Show when visible */
        }

        #menu h2 {
            font-size: 1.8rem;
            margin-bottom: 15px;
            color: var(--accent-color);
            width: 100%;
            text-align: center;
            max-width: 400px;
        }

        .menu-section {
            width: 100%;
            max-width: 400px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
        }

        .menu-section h3 {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: var(--accent-color);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 5px;
        }

        .menu-btn {
            width: 100%;
            background-color: var(--choice-bg);
            color: var(--text-color);
            border: none;
            border-radius: 5px;
            padding: 12px 15px;
            margin: 5px 0;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s;
            text-align: center;
        }

        .menu-btn:hover,
        .menu-btn:focus {
            background-color: var(--choice-hover);
            outline: none;
        }

        .menu-btn:active {
            background-color: var(--accent-color);
        }

        /* Save/load slots */
        .slot {
            /* Used by menu and title screen */
            width: 100%;
            background-color: var(--choice-bg);
            color: var(--text-color);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 12px 15px;
            margin: 8px 0;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s;
        }

        .slot.empty {
            opacity: 0.6;
        }

        /* Make empty load slots non-clickable */
        .slot.empty[data-action="load"],
        #title-load-slots .slot.empty {
            cursor: default;
        }

        .slot:not(.empty):hover,
        .slot:not(.empty):focus {
            background-color: var(--choice-hover);
            outline: none;
        }

        .slot:not(.empty):active {
            background-color: var(--accent-color);
        }

        .slot-info {
            font-size: 0.8rem;
            opacity: 0.7;
            text-align: right;
        }

        .slot-name {
            font-weight: bold;
        }


        /* Settings controls */
        .setting-control {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
            flex-wrap: wrap;
            /* Allow wrapping */
            gap: 10px;
        }

        .setting-label {
            font-size: 1rem;
            flex-basis: 100px;
            /* Give label some base width */
        }

        .setting-value {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            /* Allow buttons to wrap */
        }

        .setting-btn {
            background-color: var(--choice-bg);
            color: var(--text-color);
            border: 1px solid transparent;
            border-radius: 5px;
            padding: 6px 12px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .setting-btn:hover,
        .setting-btn:focus {
            background-color: var(--choice-hover);
            outline: none;
        }

        .setting-btn.active {
            background-color: var(--accent-color);
            border-color: rgba(255, 255, 255, 0.5);
            font-weight: bold;
        }

        /* User Message Area */
        #message-area {
            position: absolute;
            bottom: calc(var(--dialog-height) + 10px);
            /* Position above dialog */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: var(--text-color);
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 101;
            /* Above choices, below menu */
            opacity: 0;
            transition: opacity 0.4s ease, visibility 0.4s;
            visibility: hidden;
            text-align: center;
            max-width: 80%;
            font-size: 0.9rem;
            pointer-events: none;
            /* Prevent interaction */
        }

        #message-area.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Different colors for message types */
        #message-area.error {
            background-color: rgba(180, 0, 0, 0.85);
        }

        #message-area.warning {
            background-color: rgba(180, 120, 0, 0.85);
        }

        #message-area.info {
            background-color: rgba(0, 100, 180, 0.85);
        }


        /* Fade in/out animation for dialog text (effect: fade) */
        .text-fade-in {
            animation: textFadeIn var(--transition-duration) forwards;
        }

        @keyframes textFadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* Responsive Adjustments */
        @media (max-height: 650px) {
            :root {
                --dialog-height: 35vh;
            }

            #dialog-box {
                padding: 15px;
            }

            #speaker {
                font-size: 1.1rem;
                margin-bottom: 8px;
            }

            #text {
                font-size: 1rem;
            }

            #choices {
                bottom: calc(var(--dialog-height) + 5px);
                gap: 5px;
            }

            .choice {
                padding: 12px;
            }

            #message-area {
                bottom: calc(var(--dialog-height) + 5px);
            }

            /* Adjust message area position */
        }

        @media (max-width: 480px) {

            /* Adjusted breakpoint */
            #title-screen h1 {
                font-size: 2rem;
            }

            .title-button {
                font-size: 1rem;
                padding: 12px 20px;
            }

            .setting-control {
                flex-direction: column;
                align-items: flex-start;
            }

            .setting-label {
                margin-bottom: 5px;
            }

            .setting-value {
                justify-content: flex-start;
            }

            #menu h2 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>

<body>
    <!-- Loading screen -->
    <div id="loading">
        <div class="spinner"></div>
    </div>

    <!-- Title Screen -->
    <div id="title-screen">
        <h1>銀月の姫と獅子の傭兵</h1>
        <!-- ADD: aria-label for accessibility -->
        <button class="title-button" id="start-button" aria-label="ゲームを最初からはじめる">はじめから</button>
        <button class="title-button" id="load-button" aria-label="保存したゲームデータから再開する">つづきから</button>
        <button class="title-button" id="quit-button" aria-label="ゲームを終了する">終了</button>
        <!-- Load slots for Title Screen -->
        <div id="title-load-slots">
            <!-- Slots will be generated here by JS -->
            <button class="title-button menu-btn" id="title-load-back-button"
                style="width: auto; font-size: 0.9rem; padding: 8px 15px;">戻る</button>
        </div>
    </div>

    <!-- Game container -->
    <div id="game">
        <!-- Background -->
        <div id="background"></div>

        <!-- Dialog box -->
        <div id="dialog-box">
            <div id="speaker"></div>
            <div id="text"></div>
            <div id="next-indicator">▼</div>
        </div>

        <!-- Choices -->
        <div id="choices">
            <!-- Choices will be generated here by JS -->
        </div>

        <!-- Menu button -->
        <button id="menu-button" aria-label="メニューを開く" style="display: none;">☰</button>

        <!-- Menu -->
        <div id="menu">
            <h2>メニュー</h2>
            <div class="menu-section" id="save-section">
                <h3>セーブ</h3>
                <div id="save-slots">
                    <!-- Save slots will be generated here by JS -->
                </div>
            </div>
            <div class="menu-section" id="load-section">
                <h3>ロード</h3>
                <div id="load-slots">
                    <!-- Load slots will be generated here by JS -->
                </div>
            </div>
            <div class="menu-section" id="settings-section">
                <h3>設定</h3>
                <div class="setting-control">
                    <div class="setting-label">テキスト速度</div>
                    <div class="setting-value" id="text-speed-settings">
                        <button class="setting-btn" data-speed="slow">ゆっくり (100ms)</button>
                        <button class="setting-btn" data-speed="normal">ふつう (50ms)</button>
                        <button class="setting-btn" data-speed="fast">はやい (20ms)</button>
                    </div>
                </div>
                <div class="setting-control">
                    <div class="setting-label">BGM音量</div>
                    <div class="setting-value" id="bgm-volume-settings">
                        <button class="setting-btn" data-volume="0">オフ</button>
                        <button class="setting-btn" data-volume="0.3">小</button>
                        <button class="setting-btn" data-volume="0.7">中</button>
                        <button class="setting-btn" data-volume="1">大</button>
                    </div>
                </div>
                <div class="setting-control">
                    <div class="setting-label">効果音量</div>
                    <div class="setting-value" id="sfx-volume-settings">
                        <button class="setting-btn" data-volume="0">オフ</button>
                        <button class="setting-btn" data-volume="0.3">小</button>
                        <button class="setting-btn" data-volume="0.7">中</button>
                        <button class="setting-btn" data-volume="1">大</button>
                    </div>
                </div>
                <div class="setting-control">
                    <div class="setting-label">オートプレイ</div>
                    <div class="setting-value" id="auto-play-settings">
                        <button class="setting-btn" data-auto="off">オフ</button>
                        <button class="setting-btn" data-auto="on">オン (3s)</button>
                    </div>
                </div>
            </div>
            <button class="menu-btn" id="back-to-game">ゲームに戻る</button>
        </div>
    </div>

    <!-- User Message Area -->
    <div id="message-area"></div>

    <script>
        // --- Game Scope ---
        (function () { // IIFE Start

            // --- Constants ---
            const TEXT_SPEEDS = { slow: 100, normal: 50, fast: 20 };
            const AUTO_PLAY_DELAY = 3000; // ms
            const NUM_SAVE_SLOTS = 3;
            // CSS Transition Durations (ensure these match CSS variables)
            const TRANSITION_DURATION_MS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--transition-duration') || '0.5s') * 1000;
            const BACKGROUND_TRANSITION_DURATION_MS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--background-transition-duration') || '1s') * 1000;
            const MESSAGE_DISPLAY_TIME = 4000; // ms for user messages
            const RESOURCE_LOAD_TIMEOUT = 10000; // ms for image/audio loading timeout
            const TITLE_SCENE_ID = 'title'; // Constant for the title scene ID

            // --- Content Data ---
            // NOTE: Character images are currently not preloaded. Consider preloading strategy for real assets.
            const gameContent = {
                assets: {
                    backgrounds: {
                        title: 'cover04.png?text=銀月の姫と獅子の傭兵',
                        castle: 'https://via.placeholder.com/1280x720/334455/FFFFFF?text=ミラノア王国',
                        north_tower: 'https://via.placeholder.com/1280x720/223344/FFFFFF?text=北塔',
                        town: 'https://via.placeholder.com/1280x720/445566/FFFFFF?text=霧の十字路',
                        forest: 'https://via.placeholder.com/1280x720/225533/FFFFFF?text=霧の森',
                        mountain_path: 'https://via.placeholder.com/1280x720/555544/FFFFFF?text=山道',
                        village: 'https://via.placeholder.com/1280x720/556677/FFFFFF?text=銀の滝',
                        canyon: 'https://via.placeholder.com/1280x720/664433/FFFFFF?text=アストラルシズム入口',
                        temple: 'https://via.placeholder.com/1280x720/334466/FFFFFF?text=古代神殿',
                        epilogue: 'https://via.placeholder.com/1280x720/335577/FFFFFF?text=エピローグ'
                    },
                    characters: { // Character images are NOT preloaded by default in this version
                        mariabell: {
                            normal: 'https://via.placeholder.com/400x600/FFFFFF/333333?text=マリアベル',
                            disguise: 'https://via.placeholder.com/400x600/FFFFFF/333333?text=マリアベル(男装)',
                            magic: 'https://via.placeholder.com/400x600/FFFFFF/333333?text=マリアベル(魔力発動)'
                        },
                        ryan: {
                            normal: 'https://via.placeholder.com/400x600/FFFFFF/333333?text=ライアン',
                            battle: 'https://via.placeholder.com/400x600/FFFFFF/333333?text=ライアン(戦闘時)',
                            wounded: 'https://via.placeholder.com/400x600/FFFFFF/333333?text=ライアン(負傷)'
                        },
                        sofia: 'https://via.placeholder.com/400x600/FFFFFF/333333?text=ソフィア',
                        king: 'https://via.placeholder.com/400x600/FFFFFF/333333?text=ライナス国王',
                        queen: 'https://via.placeholder.com/400x600/FFFFFF/333333?text=エレノア王妃',
                        durant: 'https://via.placeholder.com/400x600/FFFFFF/333333?text=デュラント公爵',
                        nora: 'https://via.placeholder.com/400x600/FFFFFF/333333?text=ノーラ'
                    },
                    bgm: {
                        title: 'https://example.com/bgm/title.mp3', // Placeholder
                        castle: 'https://example.com/bgm/castle.mp3', // Placeholder
                        adventure: 'https://example.com/bgm/adventure.mp3', // Placeholder
                        danger: 'https://example.com/bgm/danger.mp3', // Placeholder
                        temple: 'https://example.com/bgm/temple.mp3', // Placeholder
                        epilogue: 'https://example.com/bgm/epilogue.mp3' // Placeholder
                    },
                    sfx: {
                        explosion: 'https://example.com/sfx/explosion.mp3', // Placeholder
                        magic: 'https://example.com/sfx/magic.mp3', // Placeholder
                        battle: 'https://example.com/sfx/battle.mp3', // Placeholder
                        door: 'https://example.com/sfx/door.mp3', // Placeholder
                        select: 'https://example.com/sfx/select.mp3' // Placeholder for UI sounds
                    }
                },
                scenes: [
                    // --- SCENE DATA START ---
                    // (Scene data is unchanged from the original, using placeholders)
                    {
                        id: TITLE_SCENE_ID, // Use constant
                        background: 'title',
                        // bgm: 'title', // Title BGM handled separately if needed
                        dialogs: [
                            // Title screen doesn't usually have dialogs in this setup
                        ],
                        // Choices are handled by title screen buttons now
                    },
                    {
                        id: "chapter1_1",
                        background: 'north_tower',
                        bgm: 'castle',
                        sfx: 'explosion',
                        dialogs: [
                            { text: "第1章：「運命の交差点」", effect: "fade" },
                            { text: "霧が立ち込めるミラノア王国の北塔、七階の石造りの一室で、またも小さな爆発音が響き渡った。" },
                            { text: "窓からは整然と並ぶ市街地が見え、活気ある市場や清潔な通りが王国の安定ぶりを物語っていた。" },
                            { sfx: 'door' },
                            { character: 'sofia', speaker: "ソフィア", text: "姫様！大丈夫ですか？", effect: "type" },
                            { text: "扉が勢いよく開かれ、侍女長のソフィア・ウィンドハートが煙の立ち込める室内に飛び込んできた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "大丈夫よ、ソフィア", effect: "type" },
                            { text: "煙が晴れてくると、銀色の長い髪を持つ私、マリアベル・ルミエール王女の姿が現れた。" },
                            { text: "少し焦げた裾のドレスを払いながら、不思議そうに自分の手のひらを見つめる。" },
                            { text: "左手首にある「セレナリア」と呼ばれる青白く光るブレスレットが、まるで怒りを静めるように脈打っていた。" },
                            { character: 'sofia', speaker: "ソフィア", text: "魔力が、また制御を振り切ったのね", effect: "type" },
                            { text: "ソフィアは冷静に状況を判断し、窓を開けて煙を外に逃がした。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "違うわ！魔力は完全に抑えようとしていたの。ただ、机が突然空を飛んだのよ！", effect: "type" },
                            { text: "少し頬を膨らませながら反論する。この制御できない魔力に、いつも困らされているのだ。" }
                        ],
                        choices: [{ text: "続ける", nextScene: "chapter1_2" }]
                    },
                    {
                        id: "chapter1_2",
                        background: 'north_tower',
                        bgm: 'castle',
                        dialogs: [
                            { character: 'sofia', speaker: "ソフィア", text: "机が…飛んだ？マリー、それはあなたの魔力によるものでは？", effect: "type" },
                            { text: "ソフィアは部屋を見回した。確かに、頑丈な書見台が部屋の反対側に転がっていた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "そうじゃないの！私はただ古代魔法の書物を読んでいただけよ", effect: "type" },
                            { text: "手にしていた古い羊皮紙の本を振りかざす。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "それを理解しようとしたら、急にセレナリアが熱くなって…", effect: "type" },
                            { character: 'sofia', speaker: "ソフィア", text: "とにかく、お怪我はありませんか？", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "大丈夫よ。それより、父上に知られないように片付けてくれる？お願い", effect: "type" },
                            { character: 'sofia', speaker: "ソフィア", text: "わかりました。ですが、またこのようなことがあれば、必ず国王陛下にご報告します", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "もう！ソフィアったら厳しいんだから", effect: "type" },
                            { text: "小さく口をとがらせる。王女に対する侍女としての礼節は守りつつも、こうして率直に意見することがソフィアの役目でもあった。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter1_3" }
                        ]
                    },
                    {
                        id: "chapter1_3",
                        background: 'castle',
                        bgm: 'castle',
                        dialogs: [
                            { text: "---夕刻、玉座の間での謁見---" },
                            { character: 'king', speaker: "ライナス国王", text: "マリー、何があったんだ？", effect: "type" },
                            { text: "父、ライナス・ルミエール12世は優しく尋ねた。齢五十を過ぎた国王の顔には、病と国の衰退による疲労が刻まれていたが、私を見る目は慈愛に満ちていた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "何もありませんわ、父上。いつも通り勉強をしていただけです", effect: "type" },
                            { text: "完璧な宮廷作法で膝を折り、微笑む。" },
                            { character: 'king', speaker: "ライナス国王", text: "そうか…実は大事な話がある", effect: "type" },
                            { text: "僅かに身体を強張らせる。父の声のトーンに、何か重大な決断が下されたことを感じ取ったからだ。" },
                            { character: 'king', speaker: "ライナス国王", text: "…やはりやめよう", effect: "type" },
                            { character: 'queen', speaker: "王妃", text: "あなた", effect: "type" },
                            { character: 'king', speaker: "ライナス国王", text: "だって愛しのマリーを…", effect: "type" },
                            { text: "王妃が王を睨んだ。" },
                            { character: 'king', speaker: "ライナス国王", text: "!?…こ、コホン、ルミノア連合王国からの使者が来ていた。デュラント公爵が…お前との婚姻を望んでいるそうだ", effect: "type" },
                            { text: "国王は言いながら、まるで毒でも口にしたかのように顔をしかめた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "デュラント公爵…ですか？", effect: "type" },
                            { text: "青い瞳が驚きで見開かれた。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter1_4" }
                        ]
                    },
                    {
                        id: "chapter1_4",
                        background: 'castle',
                        bgm: 'castle',
                        dialogs: [
                            { character: 'king', speaker: "ライナス国王", text: "そうだ。彼はルミノア連合王国で強い影響力を持つ貴族だ。この話はミラノアの平穏を守ることにつながる", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "公爵については噂を聞いています。古代魔法の研究に執着し、かつての朝露の魔法帝国の遺物を収集していると", effect: "type" },
                            { character: 'king', speaker: "ライナス国王", text: "ああ。彼は十年前に婚約者を失ってから、古代魔法に心酔するようになった。その力で失ったものを取り戻そうとしているのかもしれん", effect: "type" },
                            { text: "黙って父の言葉を聞いていたが、内心では嵐が吹き荒れていた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "私の意志は関係ないのですね", effect: "type" },
                            { character: 'king', speaker: "ライナス国王", text: "マリー…王家の者には、時に個人の願いを超えた責務がある。", effect: "type" },
                            { character: 'king', speaker: "ライナス国王", text: "でも！もし嫌ならば、父が何とかする！北の塔に隠してしまおうか？いや、もっと遠くの別荘に…いや、それでは私が寂しすぎる…", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "父上、国のためなら。心配なさらないで", effect: "type" },
                            { text: "優しく父の手に触れ、完璧な笑顔を作り上げる。十九年の宮廷生活で、感情を隠す術を完全に身につけていた。" },
                            { character: 'king', speaker: "ライナス国王", text: "来月初めに公爵が来訪する。その時に正式な返答をする。それまでよく考えるがいい。そして…どんな答えでも、父はお前の側にいることを忘れないでほしい", effect: "type" },
                            { text: "丁寧に膝を折り、玉座の間を後にした。廊下に出ると、完璧な仮面が少しずつ崩れていく。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter1_5" }
                        ]
                    },
                    {
                        id: "chapter1_5",
                        background: 'north_tower',
                        bgm: 'castle',
                        dialogs: [
                            { text: "---夜、北塔の自室---" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "私はこのままじゃ朽ち果ててしまうわ", effect: "type" },
                            { text: "窓辺に立ちながらソフィアに訴える。月明かりが銀髪を青白く照らし、影のように浮かび上がらせていた。" },
                            { character: 'sofia', speaker: "ソフィア", text: "デュラント公爵のことでございますか？", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "それも、でもそれだけじゃないの。この塔、この国、この呪われた力…すべてが私を閉じ込めているわ", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "もし、私が逃げ出したら、あなたは止めるの？", effect: "type" },
                            { text: "ソフィアは長い間沈黙していたが、やがて小さく首を振った。" },
                            { character: 'sofia', speaker: "ソフィア", text: "私の役目は姫様を守ることです。たとえそれが何を意味するにしても", effect: "type" },
                            { character: 'sofia', speaker: "ソフィア", text: "でも、無謀な行動は許しません。計画が必要です", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "計画…そう、逃げるためのね。手伝ってくれる？", effect: "type" },
                            { character: 'sofia', speaker: "ソフィア", text: "…仕方ありませんね。しかし条件があります。常に私と連絡を取ること、そして危険になったらすぐに戻ること", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ありがとう！", effect: "type" },
                            { text: "小さく跳ねるように喜び、ソフィアに抱きつく。それから二人で男装の準備を始めた。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter1_6" }
                        ]
                    },
                    {
                        id: "chapter1_6",
                        background: 'town',
                        bgm: 'adventure',
                        dialogs: [
                            { text: "---数日後、霧の十字路の宿場町---" },
                            { text: "「銀狼亭」という酒場に入る。旅人や傭兵、時には賞金稼ぎたちが情報と酒を交換する場所だ。" },
                            { character: 'mariabell.disguise', speaker: "フィリップ（マリアベル）", text: "私は……ただの旅人です（ゴホン）……だぜっ！", effect: "type" },
                            { text: "不自然に低い声で宣言すると、酒場の客たちが一斉に振り向いた。" },
                            { text: "思わぬ注目に戸惑いつつも、勇敢に前進する。" },
                            { character: 'mariabell.disguise', speaker: "フィリップ（マリアベル）", text: "情報を…求めておる！", effect: "type" },
                            { text: "数人の客がクスクス笑い、頬が赤く染まる。足早に奥のテーブルへと進み、客たちの会話に耳を傾ける。" },
                            { speaker: "客A", text: "なあ聞いたか？ アストラルシズム方面でまた戦があるらしいぜ", effect: "type" },
                            { speaker: "客B", text: "ああ、最近あの辺りに軍の動きがあるとか……。でも本命はお宝じゃねえの？", effect: "type" },
                            { speaker: "客A", text: "あそこには古代のお宝の噂があるからな。戦の影に隠れて回収ってわけだ", effect: "type" },
                            { speaker: "客C", text: "さっきの獣人も、あの方向に歩いていっただろ。どうせ血に飢えてんだよ", effect: "type" },
                            { text: "「アストラルシズム…」小さく呟く。古代魔法の伝承にあった場所、そして私の魔力について何か手がかりがあるかもしれない場所。" },
                            { text: "角の暗いテーブルから一人の獣人が立ち上がり、店を出るのが見える。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter1_7" }
                        ]
                    },
                    {
                        id: "chapter1_7",
                        background: 'town',
                        bgm: 'adventure',
                        dialogs: [
                            { text: "勇気を出して獣人の後を追った。" },
                            { character: 'mariabell.disguise', speaker: "マリアベル", text: "あの、すみません", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "何だガキ", effect: "type" },
                            { text: "獣人は冷たい目で私を見た。褐色の短い鬣のような髪、筋肉質の体格、そして右目の鋭い黄金色の瞳が特徴的だ。左目は大きな傷跡に覆われていた。" },
                            { character: 'mariabell.disguise', speaker: "マリアベル", text: "子供じゃないわ…じゃなくて、違う！私も…アストラルシズムに行きたいの", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "帰れ。危険な場所だ", effect: "type" },
                            { character: 'mariabell.disguise', speaker: "マリアベル", text: "私にも理由があるの。それに私、役に立つわ", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "どうやって？おまえが何者か知らないが、死にたいなら他の場所を探せ", effect: "type" },
                            { character: 'mariabell.disguise', speaker: "マリアベル", text: "いいえ、私は…", effect: "type" },
                            { sfx: 'door' },
                            { speaker: "兵士", text: "銀髪の若者を見かけた者はいないか？", effect: "type" },
                            { text: "酒場の入り口が勢いよく開かれ、王国の兵士が声高に尋ねた。体が凍りついた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…面倒な奴だ。裏口だ、来い", effect: "type" },
                            { text: "ライアンは立ち上がり、私の肩をつかんだ。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter1_8" }
                        ]
                    },
                    {
                        id: "chapter1_8",
                        background: 'town',
                        bgm: 'danger',
                        dialogs: [
                            { text: "迷路のような裏路地を、二人で息を切らせて走った。追っ手の足音がまだ遠くから聞こえてきた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "何者だ、おまえは", effect: "type" },
                            { character: 'mariabell.disguise', speaker: "マリアベル", text: "言わなかった？旅の者よ！", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "嘘をつくな。王宮の兵が一般人を追いかけたりしない", effect: "type" },
                            { text: "折れた路地の奥で、二人は一旦立ち止まった。激しく呼吸をしながら、帽子が落ちないように押さえる。" },
                            { character: 'mariabell.disguise', speaker: "マリアベル", text: "何者なのだ？あの者たちがあなたを獅子の悪魔と呼んでおりました", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "それがどうした", effect: "type" },
                            { speaker: "兵士", text: "こっちだ！見つけたぞ！", effect: "type" },
                            { text: "狭い路地の先に、王宮兵が現れた。" },
                            { speaker: "兵士", text: "そこで止まれ！", effect: "type" },
                            { text: "ライアンは咄嗟に私を背後に庇った。" },
                            { speaker: "兵士", text: "ミラノア王国第三王女マリアベル殿下、どうかお戻りください", effect: "type" },
                            { text: "ライアンの体が一瞬固まった。彼はゆっくりと私の方を振り向いた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…王女？", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ちょっとした事情があって…", effect: "type" },
                            { text: "帽子が落ち、銀髪が露わになる。申し訳なさそうな表情を浮かべた。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter1_9" }
                        ]
                    },
                    {
                        id: "chapter1_9",
                        background: 'town',
                        bgm: 'danger',
                        sfx: 'magic',
                        dialogs: [
                            { speaker: "兵士", text: "そこの者！邪魔だてするな", effect: "type" },
                            { text: "兵士が一歩近づいた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "待って！", effect: "type" },
                            { text: "前に出ようとしたとき、突然セレナリアが青白く輝き始めた。" },
                            { character: 'mariabell.magic', speaker: "マリアベル", text: "あ…魔力が…", effect: "type" },
                            { text: "体から波動のようなものが放たれ、周囲の石壁に細かなひびが入り始めた。苦しそうに腕を押さえる。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…なんだ、おまえは", effect: "type" },
                            { character: 'mariabell.magic', speaker: "マリアベル", text: "言ったでしょ、理由があるって", effect: "type" },
                            { text: "怯えた表情で答える。左手首のセレナリアが激しく脈打っていた。" },
                            { speaker: "兵士", text: "殿下の魔力が…", effect: "type" },
                            { text: "状況を見た兵士たちは一歩後ずさりした。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "このままじゃ建物が崩れる。逃げるぞ！", effect: "type" },
                            { text: "ライアンは私の手をつかみ、路地の反対側へと駆け出した。" },
                            { text: "---雨が降り始めた夜の街外れ---" },
                            { text: "追っ手から逃げ切った二人は、廃屋の軒先で息を整えていた。セレナリアを握りしめ、魔力を抑え込もうとする。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "落ち着け。呼吸を整えろ", effect: "type" },
                            { text: "言われた通りに深呼吸を繰り返し、少しずつセレナリアの光が弱まっていった。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ありがとう…", effect: "type" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter1_10" }
                        ]
                    },
                    {
                        id: "chapter1_10",
                        background: 'town',
                        bgm: 'adventure',
                        dialogs: [
                            { character: 'ryan.normal', speaker: "ライアン", text: "城に帰れ。厄介事には関わりたくない", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "帰れないわ。デュラント公爵との婚約…彼は私の魔力を利用する気なの", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "それは王家の問題だろう", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "違うわ！これは私の問題よ。私は…ずっと閉じ込められてきた。この力のせいで、この身分のせいで…", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "私はもう、誰かに決められた道を歩みたくないの", effect: "type" },
                            { text: "私の目には決意の光が宿っていた。もう、ただ守られるだけの姫ではいられない。" },
                            { text: "ライアンは長い間私を見つめていた。雨に濡れた髪を手で払いながら、深いため息をついた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…好きにしろ。でも迷惑かけるなよ", effect: "type" },
                            { text: "そのぶっきらぼうな言葉の中に、わずかな許可を感じた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ありがとう！", effect: "type" },
                            { text: "初めて本気の笑顔が広がったと思う。彼は一瞬驚いたようだったが、すぐに視線を逸らした。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "なぜ笑う。今が最悪の状況だというのに", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "違うわ。これはきっと、私の人生で最高の冒険の始まりなの", effect: "type" },
                            { text: "彼は何も言わず、ただ先に歩き出した。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "行くぞ", effect: "type" },
                            { text: "私は頷き、彼の背中を追った。銀髪の姫と獅子の傭兵——対照的な二人の、予想外の旅が始まろうとしていた。" }
                        ],
                        choices: [
                            { text: "第2章へ", nextScene: "chapter2_1" }
                        ]
                    },

                    // 第2章：静かな獅子と頑固な姫
                    {
                        id: "chapter2_1",
                        background: 'forest',
                        bgm: 'adventure',
                        dialogs: [
                            { text: "第2章：「静かな獅子と頑固な姫」", effect: "fade" },
                            { text: "霧に包まれた森の中、朝日が差し込み始めた頃、ライアンは既に起き上がり、荷物をまとめていた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "起きたか", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ん…もう朝？", effect: "type" },
                            { text: "まだ半分眠ったような声で返事をする。頬には枯れ葉の跡がついていた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "出発する", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "待って！食事は？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "時間がない。追っ手が来る前に距離を取る", effect: "type" },
                            { text: "お腹が鳴ってしまい、恥ずかしくなる。" },
                            { text: "ライアンは無言で振り返り、干し肉の切れ端を投げてくれた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "これだけ？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "贅沢を言える身分か", effect: "type" },
                            { text: "少しむっとしたが、素直に干し肉を口にする。「美味しい…」城では決して口にしなかった粗末な食べ物だけど、自由の味がした。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter2_2" }
                        ]
                    },
                    {
                        id: "chapter2_2",
                        background: 'mountain_path',
                        bgm: 'adventure',
                        dialogs: [
                            { text: "険しい山道を進む。ライアンの足取りは軽く、私は必死についていく。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "はぁ…はぁ…", effect: "type" },
                            { text: "息が切れてきた。足も痛い…" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "ついてこれないなら置いていく", effect: "type" },
                            { text: "彼の言葉は冷たいけれど、時々、彼の歩調が少しだけ緩むことに気づいていた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "大丈夫よ！これくらい…平気…", effect: "type" },
                            { text: "意地を張って歩き続ける。彼に置いていかれたくない。" },
                            { text: "頂上近くで休憩したとき、ライアンが無言で水筒を差し出してくれた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ありがとう…ライアン", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "ライアンでいい", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あなたは何者なの？獅子の悪魔って呼ばれてたわよね", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "噂だ。気にするな", effect: "type" },
                            { text: "彼はそれ以上話そうとしなかった。私も無理に聞くのはやめた。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter2_3" }
                        ]
                    },
                    {
                        id: "chapter2_3",
                        background: 'village',
                        bgm: 'adventure',
                        dialogs: [
                            { text: "山の麓にある「銀の滝」という村に着いた。宿を探すことにしたけれど…" },
                            { speaker: "宿の主人", text: "獣人？お前らの宿はない。出ていけ", effect: "type" },
                            { text: "宿の主人はライアンを見て、冷たく言い放った。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "一泊だけです。どうか", effect: "type" },
                            { text: "私が前に出ると、主人は少し態度を和らげた。" },
                            { speaker: "宿の主人", text: "獣人は外だ。お前だけなら", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "いい。俺は外で寝る。部屋を取れ", effect: "type" },
                            { text: "彼の決意の表情を見て、私は頷くしかなかった。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "どうして皆そんな態度なの？ひどいわ！", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "慣れてる。獣人にはこれが日常だ。静かにしろ。目立つな", effect: "type" },
                            { text: "彼の諦めたような表情が、私の胸を締め付けた。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter2_4" }
                        ]
                    },
                    {
                        id: "chapter2_4",
                        background: 'village', // 宿の部屋の背景がないので代用
                        bgm: 'adventure',
                        dialogs: [
                            { text: "結局、ライアンも部屋に入ってもらうことにした。二人きりになると、少し気まずい空気が流れる。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "……獣人の方と、こうして話すのは初めてかも", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "そうか", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "でも、なぜ行くの？ アストラルシズムって、命がけの場所でしょ？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "当然、報酬はもらう。あんた、王女なんだろ？", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "でも、それって命をかける理由になるの？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "……俺にとっては、そういう毎日だったんだ。昔から", effect: "type" },
                            { text: "彼の言葉に、彼の抱える孤独や過去が垣間見えた気がした。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "……ありがとう、ライアン", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "……もう寝ろ。明日は早い", effect: "type" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter2_5" }
                        ]
                    },
                    {
                        id: "chapter2_5",
                        background: 'village',
                        bgm: 'danger',
                        sfx: 'magic',
                        dialogs: [
                            { text: "真夜中、宿の周りで騒ぎが起きた。物音で目を覚ますと、ライアンが窓際に立っていた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "何かしら？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "賞金稼ぎだ。俺を追ってきた", effect: "type" },
                            { text: "外では数人の荒くれ者が「出てこい、獅子の悪魔！」と叫んでいた。" },
                            { text: "宿の主人も駆けつけ、私たちを追い出そうとする。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "行くぞ", effect: "type" },
                            { text: "ライアンの後を追い、裏庭に降り立った瞬間、三人の男が現れた。" },
                            { speaker: "賞金稼ぎ", text: "見つけたぞ！", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "逃げろ", effect: "type" },
                            { text: "私が逃げようとした瞬間、一人の男が私に飛びかかってきた。" },
                            { speaker: "賞金稼ぎ", text: "お前もあいつの仲間だろう！", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "やめて！ あ…っ！", effect: "type" },
                            { text: "とっさにセレナリアが輝き、青白い光が放たれる。魔力が暴走しそうになる。" },
                            { character: 'mariabell.magic', speaker: "マリアベル", text: "また…魔力が…", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "落ち着け！呼吸を整えろ", effect: "type" },
                            { text: "彼の声だけがはっきりと聞こえた。深呼吸をすると、少しずつ光が弱まっていく。" },
                            { text: "賞金稼ぎたちは私の力を見て「魔女か！」と叫び、逃げていった。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "危なかった…", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "制御できるようになってきたな", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "……あなたの声だけが、聞こえていた", effect: "type" },
                            { text: "小さく微笑むと、彼は少し驚いた顔をした。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter2_6" }
                        ]
                    },
                    {
                        id: "chapter2_6",
                        background: 'forest', // 安全な場所の背景代用
                        bgm: 'adventure',
                        dialogs: [
                            { text: "村を離れ、安全な場所で焚き火を囲む。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "なぜ城を出た？ ただの政略結婚が嫌なだけなら、もっと安全な逃げ場所があったはずだ。おまえが隠している本当の理由は何だ？", effect: "type" },
                            { text: "彼の鋭い指摘に、これ以上隠せないと思った。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "……デュラント公爵よ。彼は、ただ私との結婚を望んでいるわけじゃない。私の…この力を狙っているの", effect: "type" },
                            { text: "セレナリアを握りしめる。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "私の魔力は、普通のものとは違う。制御できなければ、周りを破壊してしまう…彼はそれを知っていて、自分の野心のために利用しようとしているの", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…あの時の力か", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ええ。だから逃げ出したの。彼の手に渡るわけにはいかない。アストラルシズムに何か手がかりがあるかもしれないと思ったの。ごめんなさい、あなたを巻き込んでしまって", effect: "type" },
                            { text: "彼はしばらく黙って炎を見つめていた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "なぜ、俺についてくる？ 賞金稼ぎに追われるような、獣人の傭兵だぞ", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あなただって、獅子の悪魔なんて呼ばれて、本当の自分を隠しているでしょう？", effect: "type" },
                            { text: "彼の目を見て、続ける。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "それに…理由はうまく言えないけど、あなたとなら、この運命に抗えるような気がするの。何かを変えられるって、そう感じるから", effect: "type" },
                            { text: "彼はわずかに息を呑んだように見えた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…勝手にしろ。だが、足手まといになるなよ", effect: "type" },
                            { text: "ぶっきらぼうな言葉だけど、拒絶ではない。彼の中に、何か変化が起きているのを感じた。" },
                            { text: "彼が薪を集めに森の奥へ歩いていく。月明かりに照らされた彼の背中の傷跡を見て、胸が締め付けられるような、温かい気持ちになった。" }
                        ],
                        choices: [
                            { text: "第3章へ", nextScene: "chapter3_1" }
                        ]
                    },

                    // 第3章：星空の下の告白
                    {
                        id: "chapter3_1",
                        background: 'forest',
                        bgm: 'adventure',
                        dialogs: [
                            { text: "第3章：「星空の下の告白」", effect: "fade" },
                            { text: "夜明け前の霧の森。私たちは早朝から移動を始めていた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あの雲、龍みたいね", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…龍か。確かに", effect: "type" },
                            { text: "穏やかな空気が流れていたが、突然、馬の蹄の音が聞こえてきた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "王宮の騎兵だ。隠れろ", effect: "type" },
                            { text: "しかし、既に遅かった。銀の甲冑に身を包んだ騎士たちが現れた。" },
                            { speaker: "騎士（レオン）", text: "見つけたぞ！マリー！", effect: "type" },
                            { text: "兜を脱いだのは、私の兄、レオン王子だった。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "兄さま！どうしてここに？", effect: "type" },
                            { speaker: "レオン王子", text: "貴様、我が妹に何をした？誘拐犯か？愛しのマリーを…食べる気か！", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "食べるか！", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "お兄様、違うの！彼は私の護衛で…", effect: "type" },
                            { text: "そのとき、もう一人の兄、エドワード王子が現れた。" },
                            { speaker: "エドワード王子", text: "エド兄さま！", effect: "type" },
                            { speaker: "エドワード王子", text: "兄上、また母上の命令に背いたのですか。私が捕らえるべきは、あなたです", effect: "type" },
                            { text: "兵士たちがレオン兄さまを取り囲む。" },
                            { speaker: "レオン王子", text: "なっ…！どういうことだ！マリー！", effect: "type" },
                            { text: "レオン兄さまは連れ去られていった。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "エド兄さま…", effect: "type" },
                            { speaker: "エドワード王子", text: "…マリー、母上からの伝言だ。いい機会だから見聞を広めてこい", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "え？母上が？", effect: "type" },
                            { speaker: "エドワード王子", text: "母上は常に国のことを考えている。そして、国にとって何が最善かを知っている", effect: "type" },
                            { text: "エド兄さまはライアンに意味深な視線を送り、去っていった。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "何なんだ？", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ごめんなさい。特にレオン兄さんは少し…", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "少しどころか完全に", effect: "type" },
                            { text: "思わず二人で笑ってしまった。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あなたは？家族は…", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "今はいない", effect: "type" },
                            { text: "彼の表情が曇る。私はそっと彼の腕に触れた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ごめんなさい", effect: "type" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter3_2" }
                        ]
                    },
                    {
                        id: "chapter3_2",
                        background: 'canyon', // 峡谷の高台の背景代用
                        bgm: 'adventure',
                        dialogs: [
                            { text: "夕暮れ時、私たちは峡谷の縁にある高台に着いた。遥か遠くにアストラルシズムの入口が見える。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あれがアストラルシズム…", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "ああ。明後日には着く", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "わあ、景色が素晴らしいわ！", effect: "type" },
                            { text: "崖の端に駆け寄ろうとすると、ライアンが私の腕を掴んだ。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "危険だ！死に急ぐのはやめろ", effect: "type" },
                            { text: "彼の声には本当の心配が含まれていた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "…あなたは何でも危険に見えるのね", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "生き延びるためには、全てを危険と見なす必要がある", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "でも、そうやって生きるのは疲れないの？", effect: "type" },
                            { text: "彼は答えることができなかった。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…少し離れるだけなら。だが、俺の視界から出るな", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ありがとう！", effect: "type" },
                            { text: "夕日に染まる景色は、息をのむほど美しかった。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter3_3" }
                        ]
                    },
                    {
                        id: "chapter3_3",
                        background: 'canyon', // 峡谷の高台の背景代用
                        bgm: 'temple', // 夜の静かな雰囲気に
                        dialogs: [
                            { text: "夜が深まり、満月が空高く上った。焚き火の前で体を温めていると、ライアンが少し離れたところでじっとしているのに気づいた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "どうしたの？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…何でもない", effect: "type" },
                            { text: "近づいてみると、彼の姿が変わっていた。鋭い黄金色の獅子の目が闇の中で輝き、髪は鬣のように逆立っていた。" },
                            { character: 'ryan.battle', speaker: "ライアン", text: "見るな", effect: "type" }, // 獣人化の姿としてbattleを使用
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "きれい…", effect: "type" },
                            { text: "心からそう思った。" },
                            { character: 'ryan.battle', speaker: "ライアン", text: "何を言う", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "本当よ。どうして隠すの？素敵なのに", effect: "type" },
                            { character: 'ryan.battle', speaker: "ライアン", text: "…素敵なものじゃない。この姿は呪いだ", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "私も同じ。この力は呪いだと思ってた", effect: "type" },
                            { text: "セレナリアを見つめる。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "でも今は…違うかもしれないって思えるようになった。あなたと出会ったから", effect: "type" },
                            { text: "月光に照らされた彼の黄金の目を見つめる。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "私たち似てるのね。私は力を抑えて、あなたは隠して…どちらも自分を閉じ込めてる", effect: "type" },
                            { character: 'ryan.battle', speaker: "ライアン", text: "…そうかもしれない", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "もう隠さなくていいのよ。少なくとも、私の前では。あなたのその目、嘘をつけない、真実の色をしていると思うから", effect: "type" },
                            { text: "彼は言葉を失ったように、ただ私を見つめていた。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter3_4" }
                        ]
                    },
                    {
                        id: "chapter3_4",
                        background: 'mountain_path', // 道中の背景
                        bgm: 'adventure',
                        dialogs: [
                            { text: "翌日の旅は、これまでとは少し違う雰囲気だった。ライアンは時折、自分のことを話してくれるようになった。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ライアンは元々どこに住んでいたの？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "東の大草原だ。遊牧民として生きていた", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "家族はどんな人たちだったの？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "父は部族の長…母は治療師だった。俺には二人の妹もいた", effect: "type" },
                            { text: "彼の声は静かだったが、温かみがあった。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "素敵な思い出ね", effect: "type" },
                            { text: "私の過去についても話した。北塔での窮屈な生活、ソフィアのこと、兄たちのこと。" },
                            { text: "道の脇にある奇妙な石柱を見つける。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あれは何？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "古代の道標だ。アストラルシズムへの道を示している。『深淵を越えし者に、真実は明かされん』", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "意味深ね…", effect: "type" },
                            { text: "石柱に触れると、セレナリアが青白く輝き始めた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あっ…この場所、私の魔力と共鳴してるみたい", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "アストラルシズムに近づくにつれて、反応が強くなっている", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ええ…何か呼んでいるの。ここに来るべきだった気がする", effect: "type" },
                            { text: "アストラルシズムの謎が、少しずつ私たちに近づいていた。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter3_5" }
                        ]
                    },
                    {
                        id: "chapter3_5",
                        background: 'canyon', // アストラルシズム入口
                        bgm: 'danger',
                        sfx: 'battle',
                        dialogs: [
                            { text: "夕暮れ時、アストラルシズムの入口が目の前に広がった。巨大な岩の門は荘厳で、少し怖い。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "すごい…", effect: "type" },
                            { text: "セレナリアが突然強く輝き始め、体から波動のようなものが放たれる。" },
                            { character: 'mariabell.magic', speaker: "マリアベル", text: "あ…この場所…私を呼んでる気がする", effect: "type" },
                            { text: "ライアンが私を支えてくれる。" },
                            { text: "その時、岩の門の影から人影が現れた。黒い甲冑の女性と兵士たち。" },
                            { character: 'nora', speaker: "ノーラ", text: "マリアベル姫、お会いできて光栄です。ノーラ・ファイアブラッドと申します。デュラント公爵の命により、お迎えにまいりました", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "デュラント…", effect: "type" },
                            { text: "顔から血の気が引く。ライアンが私を守るように前に立った。" },
                            { character: 'nora', speaker: "ノーラ", text: "残念ですが、選択肢はありません", effect: "type" },
                            { text: "兵士たちが武器を構え、襲いかかってくる。" },
                            { character: 'ryan.battle', speaker: "ライアン", text: "逃げろ！ 今だ！", effect: "type" },
                            { text: "ライアンは獅子のように戦い、敵を倒していく。私も隠れようとしたが、兵士に追われる。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "やめて！", effect: "type" },
                            { text: "叫ぶと同時にセレナリアが反応し、岩に亀裂が入る。力を抑えようとするが、恐怖で制御できない。" },
                            { character: 'mariabell.magic', speaker: "マリアベル", text: "もう逃げない。この力で…あなたを守る", effect: "type" },
                            { text: "決意を固め、セレナリアを両手で握る。今度は意図的に魔力を解放する。" },
                            { character: 'ryan.battle', speaker: "ライアン", text: "やめろ！制御できない！", effect: "type" },
                            { character: 'mariabell.magic', speaker: "マリアベル", text: "大丈夫…あなたがいるから", effect: "type" },
                            { text: "不思議と、魔力は制御されていた。敵の兵士たちが立っていた地面だけが崩れ、ライアンの周りは無傷だった。" },
                            { character: 'nora', speaker: "ノーラ", text: "姫の力が…制御されている？ 次は本気で来る…", effect: "type" },
                            { text: "ノーラたちは撤退していった。力を使い果たし、膝をつく私をライアンが支えてくれた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "大丈夫か？", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ええ…あなたを守れたわ", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…無謀だったぞ", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あなたに似たかしら？", effect: "type" },
                            { text: "彼は小さく笑った。" }
                        ],
                        choices: [
                            { text: "第4章へ", nextScene: "chapter4_1" }
                        ]
                    },

                    // 第4章：古代神殿の啓示
                    {
                        id: "chapter4_1",
                        background: 'canyon', // 峡谷
                        bgm: 'adventure',
                        dialogs: [
                            { text: "第4章：「古代神殿の啓示」", effect: "fade" },
                            { text: "夜明け前、私たちはアストラルシズムの巨大な入口から、峡谷の壁に沿った細い岩の階段を降り始めた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "昨日の戦いで大丈夫？", effect: "type" },
                            { text: "ライアンの腕の傷を心配する。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "問題ない。お前こそ、魔力を使い過ぎなかったか？", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "大丈夫。むしろ…初めて自分の意志で力を抑えることができた気がするわ", effect: "type" },
                            { text: "セレナリアがかすかに脈打っている。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "ノーラたちは必ず戻ってくる。次は本気で来るだろう", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "わかってる。だからこそ、早く下りましょう", effect: "type" },
                            { text: "階段は古く、所々崩れかけていた。壁には精緻な彫刻が施されている。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "これは人の手によるものね。私たちの国、ミラノアも、かつては朝露の魔法帝国と呼ばれていたのよ", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "歴史の勉強はしっかりしているようだな", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "北塔では読書くらいしかすることがなかったの", effect: "type" },
                            { text: "峡谷を降りるにつれ、奇妙な植物や青く光る花が見え始めた。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter4_2" }
                        ]
                    },
                    {
                        id: "chapter4_2",
                        background: 'canyon', // 峡谷の奥
                        bgm: 'adventure',
                        dialogs: [
                            { text: "ライアンが崖の縁に立ち、遠くを見つめていた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…おかしな話だ。何もかもが違う方向に進んでいる", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "何が？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "本来なら俺は今頃、別の戦場で剣を振るっているはずだった。いつでも去れたはずなのに", effect: "type" },
                            { text: "彼の声には戸惑いが混じっていた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あなたにとって、この旅は何なの？", effect: "type" },
                            { text: "彼は答えられなかった。でも、彼の心の中で何かが変わりつつあるのはわかった。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "わかるわ。私たち、似てるのね", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…ああ", effect: "type" },
                            { text: "初めて彼が素直に認めてくれた気がした。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter4_3" }
                        ]
                    },
                    {
                        id: "chapter4_3",
                        background: 'temple', // 神殿内部
                        bgm: 'temple',
                        sfx: 'magic',
                        dialogs: [
                            { text: "正午頃、峡谷の奥深くにある広場のような空間に着いた。中央には石柱が円を描き、台座があった。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ここは…", effect: "type" },
                            { text: "一歩踏み出すと、セレナリアが強く反応し、床の模様が光り始めた。" },
                            { character: 'mariabell.magic', speaker: "マリアベル", text: "何が起きているの…？", effect: "type" },
                            { text: "台座に近づくと、古代文字が浮かび上がる。不思議と、その文字が読めた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "『破壊と再生の調和を持つ者よ、古の扉を開け…』なぜか読めるわ…", effect: "type" },
                            { text: "台座に手を置くと、セレナリアから強い光が放たれ、地面が震え、階段が現れた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "神殿…本当にあったのか", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "行くわ", effect: "type" },
                            { text: "ライアンが先導してくれ、階段を降りる。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter4_4" }
                        ]
                    },
                    {
                        id: "chapter4_4",
                        background: 'temple', // 神殿内部
                        bgm: 'temple',
                        sfx: 'magic',
                        dialogs: [
                            { text: "階段の先は巨大な円形の広間だった。壁一面に古代文字と壁画が描かれ、中央には水晶のような本があった。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ここ…私の魔力を待ってたみたい", effect: "type" },
                            { text: "壁画には、世界を「破壊」し「再生」させる銀髪の女性と、強大な獣人の姿が描かれていた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "これは…私？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "おまえに似ている。古代の記録には、強大な力を持つ獣人のことも記されているようだな", effect: "type" },
                            { text: "水晶の本に手を伸ばすと、広間が光に包まれ、壁画が動き出した。" },
                            { text: "私の力は「破壊」だけでなく、「再生」の力も秘めていた。世界の秩序を守るための、神聖な力…" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "私の力は…世界の再生を促す力だったの？", effect: "type" },
                            { text: "今まで恐れていた力が、実は貴重な賜物だったなんて…" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "破壊と再生…バランスを保つための力", effect: "type" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter4_5" }
                        ]
                    },
                    {
                        id: "chapter4_5",
                        background: 'temple', // 神殿内部
                        bgm: 'danger',
                        sfx: 'battle',
                        dialogs: [
                            { text: "突然、地面が揺れ、神殿の入口からノーラと兵士たち、そしてデュラント公爵が現れた。" },
                            { character: 'durant', speaker: "デュラント公爵", text: "ようこそ、魔王の祭壇へ。マリアベル王女、その力は神々が残した均衡。未熟な君には扱いきれまい", effect: "type" },
                            { text: "彼の目は狂気に満ちていた。" },
                            { character: 'durant', speaker: "デュラント公爵", text: "君はかつて存在した魔王の器だ。お前に意志など不要。我が傀儡となれ", effect: "type" },
                            { character: 'ryan.battle', speaker: "ライアン", text: "ふざけるな。こいつはそんなものにはならない", effect: "type" },
                            { text: "ライアンが前に出るが、公爵は私だけを見ている。" },
                            { character: 'durant', speaker: "デュラント公爵", text: "失せろ、獣", effect: "type" },
                            { text: "ノーラと兵士たちが襲いかかってくる。ライアンは獅子の力を解放して戦う。私も魔力で援護しようとするが、敵の数が多い。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ライアン！", effect: "type" },
                            { text: "ノーラの魔法の矢がライアンの肩を貫き、彼が倒れる。" },
                            { character: 'nora', speaker: "ノーラ", text: "獅子の傭兵も、これまでか", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "やめて！彼を傷つけるなら、私も戦う", effect: "type" },
                            { text: "二人の間に立ちはだかる。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter4_6" }
                        ]
                    },
                    {
                        id: "chapter4_6",
                        background: 'temple', // 神殿内部
                        bgm: 'danger', // -> BGMを感動的なものに変える演出も考えられる
                        sfx: 'magic',
                        dialogs: [
                            { text: "突然、ライアンが立ち上がった。彼の目は完全に獅子の目に変わり、体から赤い光が発せられ始めた。力が暴走している…！" },
                            { character: 'ryan.wounded', speaker: "ライアン", text: "グオオオォォ…！", effect: "type" }, // 負傷・暴走状態
                            { text: "彼の気迫が神殿内を圧倒する。理性が失われているみたい…" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "お願い、壊さないで…！あなたはこんな人じゃない！", effect: "type" },
                            { text: "泣きながら彼に近づき、重傷の彼の手を取る。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あなたを失いたくない！", effect: "type" },
                            { text: "魂からの叫びだった。その言葉が届いたのか、彼の黄金の目に理性の光が宿った。" },
                            { character: 'ryan.wounded', speaker: "ライアン", text: "マリー…", effect: "type" },
                            { text: "その瞬間、私の「再生の力」と彼の「獅子の力」が共鳴し、神殿全体が優しい光に包まれた。" },
                            { text: "二つの力が調和し、穏やかに満ちていくのを感じる。" },
                            { character: 'durant', speaker: "デュラント公爵", text: "これが…魔王の力…シルヴィア…", effect: "type" },
                            { text: "公爵とノーラは光に押され、撤退していった。" },
                            { character: 'nora', speaker: "ノーラ", text: "力を使い果たしたか…公爵、一時撤退しましょう", effect: "type" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter4_7" }
                        ]
                    },
                    {
                        id: "chapter4_7",
                        background: 'temple', // 神殿内部
                        bgm: 'temple', // 戦闘後、静かなBGMに
                        dialogs: [
                            { text: "戦いの後、私たちは神殿の中央に座り込んでいた。二人とも疲れ果てていた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "大丈夫？", effect: "type" },
                            { text: "ライアンの傷を見る。" },
                            { character: 'ryan.wounded', speaker: "ライアン", text: "ああ…獣の体は回復が早い。おまえの魔力…癒しの力もあるんだな", effect: "type" },
                            { text: "彼の傷が徐々に癒えていくのが見える。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "うん、やっとわかったの。破壊だけじゃなく、再生の力も…この力は呪いじゃなかった", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "そうだな。俺たちの力は…正しく使えば", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "希望になれる", effect: "type" },
                            { text: "静かに微笑み合う。その時、神殿の奥から物音がした。" },
                            { text: "柱の影から、黒豹のような優雅な動きの獣人の男が現れた。" },
                            { speaker: "？？？（フェリド）", text: "壊すには惜しい", effect: "type" },
                            { text: "ライアンの体がこわばる。" },
                            { speaker: "？？？（フェリド）", text: "予想外だな…獅子と魔女の共鳴。面白い組み合わせだ", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "誰？", effect: "type" },
                            { speaker: "フェリド", text: "フェリド。本当は先にこの獅子を狩るつもりだったが…残念だ", effect: "type" },
                            { character: 'ryan.wounded', speaker: "ライアン", text: "何のために来た？", effect: "type" },
                            { speaker: "フェリド", text: "好奇心さ。久しぶりに面白い獲物を見つけたからね。魔女の力も見事だった", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "こいつに近づくな", effect: "type" }, // ライアンを守ろうとする
                            { speaker: "フェリド", text: "心配いらないよ。今日は挨拶だけ。次に会うときは…本気で遊ぼう", effect: "type" },
                            { text: "フェリドは影のように消えていった。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "……あの人、何者なの？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "知らん。だが関わるな。危険だ", effect: "type" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter4_8" }
                        ]
                    },
                    {
                        id: "chapter4_8",
                        background: 'canyon', // 帰り道
                        bgm: 'adventure',
                        dialogs: [
                            { text: "神殿からの帰り道、私たちは静かに峡谷を登っていた。互いを支え合いながら。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "私の魔力…癒しの力もあるんだね。嬉しい…この力が誰かを助けられるなんて", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "おまえは変わった。最初に会った時とは違う", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あなたも。最初はもっと怖かったわ", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "そうだったな", effect: "type" },
                            { text: "小さく笑い合う。私たちの旅はまだ終わっていないけれど、一つの答えを見つけた。私たちの力の真の意味と、それを共に使う価値を。" }
                        ],
                        choices: [
                            { text: "第5章へ", nextScene: "chapter5_1" }
                        ]
                    },

                    // 第5章：新たな道、交わる未来
                    {
                        id: "chapter5_1",
                        background: 'canyon', // 峡谷出口の野営地
                        bgm: 'castle', // 王都へ向かう気持ち
                        dialogs: [
                            { text: "第5章：「新たな道、交わる未来」", effect: "fade" },
                            { text: "峡谷の出口で野営し、星空の下で明日からの旅路を語り合った。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "王都までは、あと二日の旅程だな", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "王都に戻ったら…何をすればいいのかしら", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "おまえは王女だ。戻るべき場所がある", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "でも、もう前とは違うわ。北塔に閉じこもるつもりはない", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "現実は厳しいぞ。王族は自由に生きられない", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "なら変えればいいだけよ！私たち、もう前とは違うんだから", effect: "type" },
                            { text: "立ち上がって力強く言うと、ライアンは驚いたように私を見た。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…おまえ、時々とんでもないこと言うな", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "だって本当でしょ？あなたと一緒に旅をして、私は変われた", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…俺も", effect: "type" },
                            { text: "彼が目を逸らしながら言った言葉に、私の顔に優しい笑顔が広がった。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter5_2" }
                        ]
                    },
                    {
                        id: "chapter5_2",
                        background: 'mountain_path', // 丘陵地帯の背景代用
                        bgm: 'castle',
                        dialogs: [
                            { text: "霧深い森を抜け、開けた丘陵地帯に出ると、遠くにミラルディアの塔が見えた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あそこが私の家…", effect: "type" },
                            { text: "少し感慨深い気持ちになる。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "父に会いに行く。もう隠れない", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "王女が獣人と行動を共にしていた…問題になるぞ", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "だからこそ、変えなきゃ。あなたの汚名も晴らす", effect: "type" },
                            { text: "彼の目を見て言う。「信じてくれる？」" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…ああ", effect: "type" },
                            { text: "丘を下り始めると、馬の蹄の音が聞こえてきた。ミラノア王国の騎士団だ。先頭には宰相のエリオットがいた。" },
                            { speaker: "宰相", text: "姫…ご無事でなによりです。陛下が心配なさっています", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "父上は…お元気？すぐに会いに行くわ", effect: "type" },
                            { text: "宰相がライアンに疑いの目を向ける。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "私の友人よ。彼もともに城へご案内願います", effect: "type" },
                            { text: "宰相は一瞬躊躇ったが、頷いてくれた。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter5_3" }
                        ]
                    },
                    {
                        id: "chapter5_3",
                        background: 'castle', // 王宮内部
                        bgm: 'castle',
                        dialogs: [
                            { text: "ミラノア王国の宮殿は、荘厳で質実剛健な美しさを持っていた。長い廊下を歩きながら、何度も深呼吸をする。" },
                            { speaker: "侍女", text: "マリー様、お帰りなさい！みんな心配していました。", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "心配かけてごめんね", effect: "type" },
                            { text: "ライアンも、この宮廷の温かな雰囲気に少し驚いているようだった。" },
                            { text: "玉座の間の扉が開かれ、父上と母上がいらっしゃる。" },
                            { character: 'king', speaker: "ライナス国王", text: "マリー！愛しのマリー、無事だったか！", effect: "type" },
                            { text: "父上は玉座から飛び降り、私に駆け寄って抱きしめた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "父上…大丈夫です。ご心配をおかけして申し訳ありません", effect: "type" },
                            { character: 'queen', speaker: "王妃", text: "あなた、それくらいに。あなたが…ライアンね？", effect: "type" },
                            { text: "母上は冷静にライアンを見る。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "父上、母上、私からご報告があります", effect: "type" },
                            { text: "私は毅然とした態度で、アストラルシズムでの発見、力の真の意味、そしてデュラント公爵の陰謀について全て話した。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter5_4" }
                        ]
                    },
                    {
                        id: "chapter5_4",
                        background: 'castle', // 玉座の間
                        bgm: 'castle',
                        dialogs: [
                            { character: 'king', speaker: "ライナス国王", text: "デュラント公爵が…", effect: "type" },
                            { text: "父上は考え込んでいる。" },
                            { speaker: "宰相", text: "陛下、姫君の話には信頼性があります。我々の情報網からも、デュラント公爵の不審な動きが報告されています", effect: "type" },
                            { character: 'queen', speaker: "王妃", text: "そして…セレナリアが共鳴したということは、古の力が彼女に宿っているという証でもあります", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "母上、あなたも知っていたの？", effect: "type" },
                            { character: 'queen', speaker: "王妃", text: "ふふ…私の耳と目は王国の隅々まで届いているのよ。アストラルシズムの動きはずっと監視していたわ", effect: "type" },
                            { character: 'queen', speaker: "王妃", text: "あなたの旅立ちも…デュラントがあそこまでするとは思わなかったけれど。危険な目に合わせてごめんね", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "それなのに止めなかったのですか？", effect: "type" },
                            { character: 'queen', speaker: "王妃", text: "力は使われてこそ磨かれる。北塔に閉じ込めたままでは、あなたの真価は発揮されない。それに…あなたの隣には頼もしい獅子がいたようね", effect: "type" },
                            { text: "母上の言葉に頬が赤くなる。ライアンは視線を逸らした。" },
                            { character: 'king', speaker: "ライナス国王", text: "マリアベル、おまえの選んだ道は？", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "私の力を、この国のために使います。でも、自分の意志で。私は恐れられる姫じゃない。信じられる王女になるわ。そして、獣人と人間の架け橋にもなりたい", effect: "type" },
                            { character: 'king', speaker: "ライナス国王", text: "見てみろ、エレノア！愛しのマリーが、こんなに立派に輝いている！", effect: "type" },
                            { text: "父上は涙ぐんでいる。" },
                            { speaker: "宰相", text: "陛下、姫君を特使として、各国へ派遣してはいかがでしょう", effect: "type" },
                            { character: 'king', speaker: "ライナス国王", text: "良い考えだな。マリー、特使として、我が国の代表となれるか？", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "はい、父上！", effect: "type" },
                            { text: "喜びで胸がいっぱいになる。ライアンを振り返ると、彼は静かに微笑んでいた。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter5_5" }
                        ]
                    },
                    {
                        id: "chapter5_5",
                        background: 'castle', // 庭園の背景がないので代用
                        bgm: 'epilogue', // 別れの予感
                        dialogs: [
                            { text: "その夜、宮殿の庭園で月を見上げているライアンを見つけた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ここにいるとわかっていたわ", effect: "type" },
                            { text: "私は王宮の衣装ではなく、簡素な旅装束に着替えていた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "おまえは…その衣装は…", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "旅の準備よ。特使としての最初の任務。ルミノア連合王国との交渉。自由に動けるようにね", effect: "type" },
                            { text: "静かに並んで月を見上げる。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あなたは…これからどうするの？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "傭兵の仕事を続ける。だが、今度は少し違う視点で。見るべき景色を探しながら旅をしてみたい", effect: "type" },
                            { text: "彼の変化が嬉しい。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ライアン…また会えるよね？ 約束して", effect: "type" },
                            { text: "彼の手を取る。彼は驚いたようだったが、小さく頷いた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "約束する", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ありがとう", effect: "type" },
                            { text: "安堵の笑みが広がる。" }
                        ],
                        choices: [
                            { text: "続ける", nextScene: "chapter5_6" }
                        ]
                    },
                    {
                        id: "chapter5_6",
                        background: 'canyon', // アストラルシズム入口
                        bgm: 'epilogue',
                        dialogs: [
                            { text: "数日後、アストラルシズムの入口で、私たちは再び立っていた。別れの時。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "私、行かなきゃ", effect: "type" },
                            { text: "足が動かない。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "ああ", effect: "type" },
                            { text: "彼も同じように動けずにいる。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あなたは…私にとって…", effect: "type" },
                            { text: "言葉に詰まる。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "言わなくていい。言葉にする必要はない", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "じゃあ、行ってくるわ。次に会ったとき、たくさんの物語を聞かせて", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "ああ。気をつけろよ", effect: "type" },
                            { text: "彼の表情は、初めて会った時よりもずっと柔らかく、温かい。" },
                            { text: "一歩、また一歩と彼から離れる。振り返ると、彼はまだそこに立っていた。" },
                            { text: "彼の口が小さく動くのが見えた気がした。「待っている」と。風の音にかき消されたけれど、彼の気持ちは伝わってきた。" },
                            { text: "胸の奥が温かくなり、前を向く力が湧いてくる。今は進むべき時。でも、この繋がりは決して途切れない。" },
                            { text: "私は確かな足取りで歩き出した。" }
                        ],
                        choices: [{ text: "エピローグへ", nextScene: "epilogue_1" }]
                    },
                    {
                        id: "epilogue_1",
                        background: 'epilogue', // Use epilogue background
                        bgm: 'epilogue',
                        dialogs: [
                            { text: "エピローグ", effect: "fade" },
                            { text: "一年後、アストラルシズムの入口。" },
                            { text: "夕日に照らされた峡谷に、二つの影が伸びていた。私は約束通り、ここに戻ってきた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "待たせたわね。約束通り来たのよ", effect: "type" },
                            { text: "彼はそこにいた。以前よりも穏やかな表情で。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "ああ、おかえり", effect: "type" },
                            { text: "一年の間に、私たちはそれぞれの道を歩み、成長してきた。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "どんな旅だった？", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "様々だ。東の渓谷では断崖の上に建つ村を見た。月光に照らされた湖は、まるでおまえの髪のようだった", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "あなたが風景に例え事をするなんて、変わったのね", effect: "type" },
                            { text: "彼は少し恥ずかしそうに視線を逸らした。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "旅をしていると…見えるものも変わる。おまえは？特使としての任務は", effect: "type" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "うまくいったわ。ルミノア連合王国との間に、新たな協定を結ぶことができたの", effect: "type" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "そうか。おまえらしいな", effect: "type" },
                            { text: "太陽が地平線に沈み始める。" }
                        ],
                        choices: [{ text: "続ける", nextScene: "epilogue_2" }]
                    },
                    {
                        id: "epilogue_2",
                        background: 'epilogue', // Use epilogue background
                        bgm: 'epilogue',
                        dialogs: [
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "ねえ、私の護衛してくれない？ 近々、南方諸国への特使として派遣されるの", effect: "type" },
                            { text: "少し照れくさかったけど、聞いてみた。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "報酬次第だな", effect: "type" },
                            { text: "彼は一瞬驚いたようだったけど、いつもの無愛想な顔に戻った。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "もちろん、王国最高の待遇よ", effect: "type" },
                            { text: "クスリと笑う。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "…悪くない話だ", effect: "type" },
                            { text: "彼の口元にかすかな笑みが浮かんでいる。" },
                            { text: "私はゆっくりと彼に近づき、手を差し伸べた。彼はその手を取ってくれた。温かい絆を感じる。" },
                            { text: "私たちは手を取り合ったまま、夕暮れの中を歩き始めた。道はまだ続いている。試練も困難も待っているだろう。でも、もう一人じゃない。" },
                            { character: 'mariabell.normal', speaker: "マリアベル", text: "新しい冒険の始まりね", effect: "type" },
                            { text: "夜空を見上げる。" },
                            { character: 'ryan.normal', speaker: "ライアン", text: "ああ。新たな道、交わる未来へ", effect: "type" },
                            { text: "彼は私の手をしっかりと握りしめた。" },
                            { text: "私たちの物語は、これからも続いていく。" },
                            { text: "--- 完 ---", effect: "fade" }
                        ],
                        choices: [
                            { text: "タイトルへ", nextScene: TITLE_SCENE_ID } // Use constant, loop back to title
                        ]
                    }
                    // --- SCENE DATA END ---
                ]
            };

            // Function to encode URLs in gameContent (unchanged)
            function encodeGameAssetUrls(content) {
                const encodeUrlTextParam = (url) => {
                    if (!url || typeof url !== 'string') return url;
                    const textParamIndex = url.indexOf('?text=');
                    if (textParamIndex !== -1) {
                        const baseUrl = url.substring(0, textParamIndex + 6); // Include '?text='
                        const textValue = url.substring(textParamIndex + 6);
                        try {
                            return baseUrl + encodeURIComponent(textValue);
                        } catch (e) {
                            console.error(`Failed to encode URI component: ${textValue}`, e);
                            return url; // Return original URL on error
                        }
                    }
                    return url; // Return original URL if no text param
                };
                if (content.assets.backgrounds) {
                    for (const key in content.assets.backgrounds) {
                        content.assets.backgrounds[key] = encodeUrlTextParam(content.assets.backgrounds[key]);
                    }
                }
                if (content.assets.characters) {
                    for (const charKey in content.assets.characters) {
                        const charAsset = content.assets.characters[charKey];
                        if (typeof charAsset === 'string') {
                            content.assets.characters[charKey] = encodeUrlTextParam(charAsset);
                        } else if (typeof charAsset === 'object' && charAsset !== null) {
                            for (const poseKey in charAsset) {
                                charAsset[poseKey] = encodeUrlTextParam(charAsset[poseKey]);
                            }
                        }
                    }
                }
            }

            // Immediately encode the URLs after defining gameContent
            encodeGameAssetUrls(gameContent);

            // --- Game State ---
            const gameState = {
                currentSceneId: null,
                currentDialogIndex: 0,
                isTyping: false,
                typingTimeoutId: null, // Can be Timeout ID (number) or RAF ID (number)
                isShowingChoices: false,
                isMenuOpen: false,
                settings: {
                    textSpeed: 'normal',
                    bgmVolume: 0.7,
                    sfxVolume: 0.7,
                    autoPlay: false
                },
                autoPlayTimerId: null,
                isFirstInteractionDone: false, // Changed from isFirstInteraction for clarity
                isBackgroundTransitioning: false,
                isTitleScreen: true, // Start on title screen
                messageTimeoutId: null // For user message display timeout
            };

            // --- Resource Loader ---
            const resourceLoader = {
                cache: { images: {}, audio: {} },

                async preloadResources() {
                    // console.log("Starting resource preloading...");
                    const promises = [];
                    if (gameContent.assets.backgrounds) {
                        Object.entries(gameContent.assets.backgrounds).forEach(([key, src]) => {
                            if (src && !this.cache.images[src]) {
                                promises.push(this.preloadImage(key, src).catch(err => {
                                    console.warn(`Failed to preload background ${key}:`, err);
                                    // Optionally show user message: showUserMessage(`背景画像の読み込みに失敗: ${key}`, 'warning');
                                    return null;
                                }));
                            }
                        });
                    }
                    if (gameContent.assets.bgm) {
                        Object.entries(gameContent.assets.bgm).forEach(([key, src]) => {
                            if (src && !this.cache.audio[src]) {
                                promises.push(this.preloadSingleAudio(key, src, 'bgm').catch(err => {
                                    console.warn(`Failed to preload BGM ${key}:`, err);
                                    // Optionally show user message: showUserMessage(`BGMの読み込みに失敗: ${key}`, 'warning');
                                    return null;
                                }));
                            }
                        });
                    }
                    if (gameContent.assets.sfx) {
                        Object.entries(gameContent.assets.sfx).forEach(([key, src]) => {
                            if (src && !this.cache.audio[src]) {
                                promises.push(this.preloadSingleAudio(key, src, 'sfx').catch(err => {
                                    console.warn(`Failed to preload SFX ${key}:`, err);
                                    // Optionally show user message: showUserMessage(`効果音の読み込みに失敗: ${key}`, 'warning');
                                    return null;
                                }));
                            }
                        });
                    }
                    try {
                        const results = await Promise.all(promises);
                        const failedCount = results.filter(r => r === null).length;
                        if (failedCount > 0) {
                            console.warn(`${failedCount} resource(s) failed to preload.`);
                            return false;
                        }
                        // console.log("Resource preloading completed successfully.");
                        return true;
                    } catch (error) {
                        console.error("Resource preloading failed:", error);
                        return false;
                    }
                },

                preloadImage(key, src) {
                    return new Promise((resolve, reject) => {
                        if (!src) { reject(`Invalid src for image key: ${key}`); return; }
                        if (this.cache.images[src]) { resolve(key); return; } // Already cached
                        const img = new Image();
                        let timeoutId = setTimeout(() => {
                            img.onload = img.onerror = null; // Clean up listeners
                            reject(`Timeout loading image: ${key} (${src})`);
                        }, RESOURCE_LOAD_TIMEOUT);
                        img.onload = () => {
                            clearTimeout(timeoutId);
                            this.cache.images[src] = img;
                            resolve(key);
                        };
                        img.onerror = (err) => {
                            clearTimeout(timeoutId);
                            reject(`Failed to load image: ${key} (${src}) - Error: ${err?.type || 'Unknown'}`);
                        };
                        img.src = src;
                    });
                },

                preloadSingleAudio(key, src, type) {
                    return new Promise((resolve, reject) => {
                        if (!src) { reject(`Invalid src for audio key: ${key} (${type})`); return; }
                        if (this.cache.audio[src]) { resolve(key); return; } // Already cached
                        const audio = new Audio();
                        let timeoutId = setTimeout(() => {
                            audio.oncanplaythrough = audio.onerror = null; // Clean up listeners
                            reject(`Timeout loading audio (${type}): ${key} (${src})`);
                        }, RESOURCE_LOAD_TIMEOUT);
                        audio.oncanplaythrough = () => {
                            clearTimeout(timeoutId);
                            this.cache.audio[src] = audio;
                            resolve(key);
                        };
                        audio.onerror = (err) => {
                            clearTimeout(timeoutId);
                            const errorDetail = audio.error ? `Code: ${audio.error.code}, Message: ${audio.error.message}` : (err?.type || 'Unknown');
                            reject(`Failed to load audio (${type}): ${key} (${src}) - Error: ${errorDetail}`);
                        };
                        audio.preload = 'auto';
                        audio.src = src;
                    });
                },

                getImageSrc(key) {
                    return gameContent.assets.backgrounds?.[key];
                },

                getAudioSrc(key, type = 'bgm') {
                    return gameContent.assets[type]?.[key];
                }
            };

            // --- Audio Manager ---
            const audioManager = {
                bgmAudio: null,
                sfxPool: {},
                activeBgmKey: null,

                async init() {
                    this.bgmAudio = new Audio();
                    this.bgmAudio.loop = true;
                    this.updateVolume(); // Apply initial volume (possibly loaded from settings)

                    if (gameContent.assets.sfx) {
                        for (const [key, src] of Object.entries(gameContent.assets.sfx)) {
                            if (src) {
                                const cachedAudio = resourceLoader.cache.audio[src];
                                this.sfxPool[key] = Array(3).fill(null).map(() => {
                                    const audio = cachedAudio ? cachedAudio.cloneNode() : new Audio(src);
                                    audio.volume = gameState.settings.sfxVolume;
                                    return audio;
                                });
                            }
                        }
                    }
                    // console.log("Audio Manager Initialized");
                },

                // Attempt to unlock audio context on first user interaction
                ensureAudioResumed() {
                    if (!gameState.isFirstInteractionDone && (!this.bgmAudio || this.bgmAudio.paused)) {
                        // console.log("Attempting to resume audio context on first interaction...");
                        const silentAudio = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');
                        silentAudio.volume = 0;
                        silentAudio.play().then(() => {
                            // console.log("Audio context likely resumed.");
                            gameState.isFirstInteractionDone = true; // Mark interaction happened
                            // If BGM should be playing, try playing it now
                            if (this.bgmAudio && this.bgmAudio.src && this.bgmAudio.paused && this.activeBgmKey) {
                                // console.log(`Attempting to play BGM ${this.activeBgmKey} after context resume.`);
                                this.bgmAudio.play().catch(e => console.warn("BGM play failed after context resume:", e));
                            }
                        }).catch(e => {
                            console.warn("Silent audio play failed, context might still be locked:", e);
                            gameState.isFirstInteractionDone = true; // Still mark interaction happened to avoid repeats
                        });
                    } else if (!gameState.isFirstInteractionDone) {
                        gameState.isFirstInteractionDone = true; // Mark interaction if audio was already playing
                    }
                },

                playBGM(bgmKey) {
                    // No need to call ensureAudioResumed here, it's called on interaction
                    const src = resourceLoader.getAudioSrc(bgmKey, 'bgm');
                    if (!src) {
                        this.stopBGM();
                        console.warn(`BGM key "${bgmKey}" not found.`);
                        return;
                    }
                    if (!this.bgmAudio) { console.error("BGM Audio element not initialized."); return; }

                    const requiresPlay = !this.bgmAudio.src || this.bgmAudio.src !== src || this.bgmAudio.paused;

                    if (bgmKey !== this.activeBgmKey || requiresPlay) {
                        // console.log(`Setting BGM: ${bgmKey}`);
                        this.activeBgmKey = bgmKey;
                        this.bgmAudio.volume = gameState.settings.bgmVolume;
                        if (this.bgmAudio.src !== src) {
                            this.bgmAudio.src = src;
                        }

                        // Only try to play if user interaction has happened
                        if (gameState.isFirstInteractionDone) {
                            this.bgmAudio.play().catch(e => {
                                // Log specific errors for debugging autoplay policy issues
                                if (e.name === 'NotAllowedError') {
                                    // This should ideally not happen often if ensureAudioResumed works
                                    console.warn(`BGM playback for ${bgmKey} blocked by autoplay policy. Interaction might be needed.`);
                                } else {
                                    console.warn(`BGM playback failed for ${bgmKey}:`, e.name, e.message);
                                }
                            });
                        } else {
                            console.log(`BGM ${bgmKey} queued. Will play after first user interaction.`);
                            // Ensure it tries to play later via ensureAudioResumed
                        }
                    }
                },

                stopBGM() {
                    if (this.bgmAudio && !this.bgmAudio.paused) {
                        this.bgmAudio.pause();
                        this.bgmAudio.currentTime = 0;
                        this.activeBgmKey = null;
                        // console.log("Stopping BGM");
                    } else {
                        // Ensure key is cleared even if paused
                        this.activeBgmKey = null;
                    }
                },

                playSFX(sfxKey) {
                    // No need to call ensureAudioResumed here
                    const pool = this.sfxPool[sfxKey];
                    if (!pool || pool.length === 0) {
                        const src = resourceLoader.getAudioSrc(sfxKey, 'sfx');
                        if (src) {
                            // console.warn(`SFX pool for "${sfxKey}" not found or empty, attempting direct play.`);
                            if (gameState.isFirstInteractionDone) { // Play only after interaction
                                try {
                                    const sfxAudio = new Audio(src);
                                    sfxAudio.volume = gameState.settings.sfxVolume;
                                    sfxAudio.play().catch(e => console.warn(`Direct SFX playback failed for ${sfxKey}:`, e));
                                } catch (error) {
                                    console.error(`Error creating Audio for SFX: ${sfxKey}`, error);
                                }
                            } // else: Silently fail if no interaction yet
                        } else {
                            console.warn(`SFX source not found for key: ${sfxKey}`);
                        }
                        return;
                    }

                    // Only play SFX if user interaction has occurred
                    if (!gameState.isFirstInteractionDone) {
                        // console.log(`SFX ${sfxKey} skipped, requires user interaction first.`);
                        return;
                    }

                    const availableSfx = pool.find(audio => audio.paused || audio.ended);
                    if (availableSfx) {
                        availableSfx.currentTime = 0;
                        availableSfx.volume = gameState.settings.sfxVolume;
                        availableSfx.play().catch(e => console.warn(`SFX pool playback failed for ${sfxKey}:`, e.name, e.message));
                    } else {
                        console.warn(`SFX pool for "${sfxKey}" is full, sound dropped.`);
                    }
                },

                updateVolume() {
                    const bgmVol = gameState.settings.bgmVolume;
                    const sfxVol = gameState.settings.sfxVolume;
                    if (this.bgmAudio) { this.bgmAudio.volume = bgmVol; }
                    Object.values(this.sfxPool).forEach(pool => {
                        pool.forEach(audio => { if (audio) audio.volume = sfxVol; });
                    });
                }
            };


            // --- Save/Load Manager ---
            const saveManager = {
                saveCache: {},

                initCache() {
                    for (let i = 1; i <= NUM_SAVE_SLOTS; i++) {
                        try {
                            const data = localStorage.getItem(`save_${i}`);
                            this.saveCache[i] = data ? JSON.parse(data) : null;
                        } catch (e) {
                            console.error(`Error loading/parsing save slot ${i} from localStorage:`, e);
                            this.saveCache[i] = null;
                            try { localStorage.removeItem(`save_${i}`); } catch (removeError) { /* Ignore cleanup error */ }
                        }
                    }
                    // console.log("Save cache initialized:", this.saveCache);
                },

                save(slot) {
                    if (gameState.isTyping || gameState.isShowingChoices || gameState.isBackgroundTransitioning || gameState.isMenuOpen) {
                        showUserMessage("テキスト表示中、選択肢表示中、背景切り替え中、またはメニュー表示中はセーブできません。", "warning");
                        return false;
                    }
                    if (gameState.isTitleScreen) {
                        showUserMessage("タイトル画面ではセーブできません。", "warning");
                        return false;
                    }
                    if (!gameState.currentSceneId) {
                        showUserMessage("セーブ可能なシーンではありません。", "warning");
                        return false;
                    }

                    const saveData = {
                        sceneId: gameState.currentSceneId,
                        dialogIndex: gameState.currentDialogIndex,
                        settings: { ...gameState.settings }, // Save a copy of settings
                        timestamp: new Date().toISOString()
                    };

                    try {
                        const dataString = JSON.stringify(saveData);
                        localStorage.setItem(`save_${slot}`, dataString);
                        this.saveCache[slot] = saveData;
                        console.log(`Game saved to slot ${slot}`);
                        updateSlotUI(slot);
                        showUserMessage(`スロット ${slot} にセーブしました。`, "info");
                        return true;
                    } catch (e) {
                        console.error('Failed to save game to localStorage:', e);
                        let message = `セーブ失敗: 不明なエラーが発生しました (${e.name})。`;
                        if (e.name === 'QuotaExceededError' || (e.message && e.message.toLowerCase().includes('quota'))) {
                            message = "セーブ失敗: ブラウザのストレージ容量がいっぱいです。不要なデータを削除してください。";
                        } else if (e.name === 'SecurityError') {
                            message = "セーブ失敗: ブラウザの設定によりストレージへのアクセスがブロックされています。";
                        }
                        showUserMessage(message, "error", 6000); // Show longer for error
                        return false;
                    }
                },

                load(slot, onSuccessCallback) {
                    clearAutoPlayTimer();
                    const saveData = this.saveCache[slot];

                    if (!saveData) {
                        showUserMessage(`スロット ${slot} にはセーブデータがありません。`, "warning");
                        return false;
                    }

                    try {
                        // --- Enhanced Validation ---
                        if (typeof saveData !== 'object' || saveData === null) throw new Error("セーブデータ形式が無効です。");
                        if (typeof saveData.sceneId !== 'string' || !saveData.sceneId) throw new Error("セーブデータにシーンIDが含まれていません。");
                        if (typeof saveData.dialogIndex !== 'number' || saveData.dialogIndex < 0) throw new Error("セーブデータのダイアログインデックスが無効です。");
                        if (saveData.settings && typeof saveData.settings !== 'object') throw new Error("セーブデータの設定形式が無効です。");
                        // --- End Enhanced Validation ---

                        const sceneExists = gameContent.scenes.find(s => s.id === saveData.sceneId);
                        if (!sceneExists) {
                            throw new Error(`保存されたシーンID (${saveData.sceneId}) が現在のゲームデータに見つかりません。`);
                        }

                        // Adjust invalid dialog index (allow index == length for choice display)
                        const maxDialogIndex = sceneExists.dialogs ? sceneExists.dialogs.length : 0;
                        if (saveData.dialogIndex > maxDialogIndex) {
                            console.warn(`Invalid dialog index (${saveData.dialogIndex}) in save data for scene ${saveData.sceneId}. Resetting to 0.`);
                            saveData.dialogIndex = 0;
                        }

                        // Restore settings *before* loading scene
                        // Merge saved settings with defaults to handle missing/new properties
                        const mergedSettings = { ...gameState.settings, ...(saveData.settings || {}) };
                        updateGameState({ settings: mergedSettings });
                        updateSettingsUI();
                        audioManager.updateVolume();

                        // Ensure first interaction state is reset if loading a saved game
                        // because the loaded state might require audio playback immediately.
                        // We will rely on ensureAudioResumed being called by the interaction
                        // that *triggered* the load or the first interaction after load.
                        // gameState.isFirstInteractionDone = false; // Reset this? Maybe not needed.

                        // Load scene and dialog state
                        loadScene(saveData.sceneId, saveData.dialogIndex);
                        console.log(`Game loaded from slot ${slot}`);

                        if (typeof onSuccessCallback === 'function') {
                            onSuccessCallback();
                        }

                        showUserMessage(`スロット ${slot} からロードしました。`, "info");
                        return true;

                    } catch (e) {
                        console.error('Failed to load game state:', e);
                        showUserMessage(`ロード処理中にエラーが発生しました: ${e.message}`, "error", 6000);
                        return false;
                    }
                },

                getSaveData(slot) {
                    const cached = this.saveCache[slot];
                    return cached ? { ...cached, slot, isEmpty: false } : { slot, isEmpty: true };
                },

                getAllSaveData() {
                    return Array.from({ length: NUM_SAVE_SLOTS }, (_, i) => this.getSaveData(i + 1));
                }
            };

            // --- DOM Elements Cache ---
            const elements = {
                loading: document.getElementById('loading'),
                titleScreen: document.getElementById('title-screen'),
                startButton: document.getElementById('start-button'),
                loadButton: document.getElementById('load-button'),
                quitButton: document.getElementById('quit-button'),
                titleLoadSlotsContainer: document.getElementById('title-load-slots'),
                titleLoadBackButton: document.getElementById('title-load-back-button'),
                game: document.getElementById('game'),
                background: document.getElementById('background'),
                dialogBox: document.getElementById('dialog-box'),
                speaker: document.getElementById('speaker'),
                text: document.getElementById('text'),
                nextIndicator: document.getElementById('next-indicator'),
                choices: document.getElementById('choices'),
                menuButton: document.getElementById('menu-button'),
                menu: document.getElementById('menu'),
                saveSlotsContainer: document.getElementById('save-slots'),
                loadSlotsContainer: document.getElementById('load-slots'),
                settingsSection: document.getElementById('settings-section'),
                textSpeedSettings: document.getElementById('text-speed-settings'),
                bgmVolumeSettings: document.getElementById('bgm-volume-settings'),
                sfxVolumeSettings: document.getElementById('sfx-volume-settings'),
                autoPlaySettings: document.getElementById('auto-play-settings'),
                backToGame: document.getElementById('back-to-game'),
                messageArea: document.getElementById('message-area')
            };

            // --- Utility Functions ---
            function showUserMessage(message, type = "info", duration = MESSAGE_DISPLAY_TIME) {
                if (!elements.messageArea) { console.warn("Message area element not found."); return; }
                if (gameState.messageTimeoutId) {
                    clearTimeout(gameState.messageTimeoutId);
                    gameState.messageTimeoutId = null;
                }
                elements.messageArea.textContent = message;
                elements.messageArea.className = `message-area ${type} visible`; // Use #message-area class

                gameState.messageTimeoutId = setTimeout(() => {
                    elements.messageArea.classList.remove('visible');
                    // Use transitionend listener for cleanup after fade out
                    const cleanup = () => {
                        if (!elements.messageArea.classList.contains('visible')) {
                            elements.messageArea.className = 'message-area'; // Reset class
                            elements.messageArea.removeEventListener('transitionend', cleanup);
                        }
                    };
                    elements.messageArea.addEventListener('transitionend', cleanup, { once: true }); // Use once: true
                    gameState.messageTimeoutId = null;
                }, duration);
            }

            function optimizedScroll(element) {
                if (element && element.scrollHeight > element.clientHeight) {
                    requestAnimationFrame(() => {
                        if (element.scrollHeight > element.clientHeight) {
                            if ('scrollBehavior' in document.documentElement.style) {
                                element.scrollTo({ top: element.scrollHeight, behavior: 'smooth' });
                            } else {
                                element.scrollTop = element.scrollHeight;
                            }
                        }
                    });
                }
            }

            function sanitizeText(str) {
                if (typeof str !== 'string') return '';
                return str.replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;')
                    .replace(/\n/g, '<br>');
            }

            // --- Core Game Logic ---
            function updateGameState(updates) {
                const prevState = { ...gameState };
                Object.assign(gameState, updates);

                // --- Handle State Change Side Effects ---
                if (prevState.isTyping !== gameState.isTyping) {
                    if (!gameState.isTyping && !gameState.isShowingChoices && !gameState.isBackgroundTransitioning && !gameState.isTitleScreen && !gameState.isMenuOpen) {
                        elements.nextIndicator.style.display = 'block';
                        setupAutoPlayTimer();
                    } else {
                        elements.nextIndicator.style.display = 'none';
                        clearAutoPlayTimer();
                    }
                }

                if (prevState.settings.autoPlay !== gameState.settings.autoPlay) {
                    if (gameState.settings.autoPlay) {
                        if (!gameState.isTyping && !gameState.isShowingChoices && !gameState.isBackgroundTransitioning && !gameState.isTitleScreen && !gameState.isMenuOpen) {
                            setupAutoPlayTimer();
                        }
                    } else {
                        clearAutoPlayTimer();
                    }
                }

                if (prevState.isTitleScreen !== gameState.isTitleScreen) {
                    if (gameState.isTitleScreen) {
                        showTitleScreen();
                    } else {
                        hideTitleScreen();
                    }
                }
                // Menu open/close state is handled by open/closeMenu to manage transitions
            }

            function saveSettings() {
                try {
                    localStorage.setItem('gameSettings', JSON.stringify(gameState.settings));
                } catch (e) {
                    console.warn("Could not save settings to localStorage:", e);
                    let message = "設定の保存に失敗しました。";
                    if (e.name === 'QuotaExceededError' || (e.message && e.message.toLowerCase().includes('quota'))) {
                        message = "設定の保存失敗: ブラウザのストレージ容量がいっぱいです。";
                    }
                    showUserMessage(message, "warning");
                }
            }

            function cleanupScene() {
                clearAutoPlayTimer();
                if (gameState.typingTimeoutId) {
                    // Determine type based on value (simple heuristic)
                    if (typeof gameState.typingTimeoutId === 'number' && gameState.typingTimeoutId < 100000) { // Assume RAF ID is smaller
                        cancelAnimationFrame(gameState.typingTimeoutId);
                    } else if (typeof gameState.typingTimeoutId === 'number') { // Assume Timeout ID
                        clearTimeout(gameState.typingTimeoutId);
                    }
                    gameState.typingTimeoutId = null;
                }

                // Reset background transition state if interrupted
                if (gameState.isBackgroundTransitioning) {
                    console.warn("Cleaning up potentially interrupted background transition.");
                    // Force remove class and reset state. Listeners with {once: true} should clean themselves up.
                    elements.background.classList.remove('fade');
                    gameState.isBackgroundTransitioning = false;
                }
            }

            function loadScene(sceneId, startDialogIndex = 0) {
                // console.log(`Loading scene: ${sceneId}, start dialog: ${startDialogIndex}`);
                if (gameState.isBackgroundTransitioning) {
                    // Debounce: If already transitioning, maybe queue the next load?
                    // For now, just warn and abort.
                    console.warn("Attempted to load scene during background transition. Aborting.");
                    return;
                }
                cleanupScene();

                const scene = gameContent.scenes.find(s => s.id === sceneId);
                if (!scene) {
                    console.error(`Scene with id "${sceneId}" not found!`);
                    showUserMessage(`エラー：シーン「${sceneId}」が見つかりません。タイトルに戻ります。`, "error", 6000);
                    updateGameState({ isTitleScreen: true, currentSceneId: null, currentDialogIndex: 0 });
                    return;
                }

                // Ensure game container is visible if coming from title
                if (!elements.game.classList.contains('visible')) {
                    elements.game.classList.add('visible');
                }

                // Update core game state
                updateGameState({
                    currentSceneId: sceneId,
                    currentDialogIndex: startDialogIndex,
                    isShowingChoices: false,
                    isTyping: false,
                    isMenuOpen: false // Ensure menu is closed
                });

                // Reset UI elements
                elements.choices.innerHTML = ''; // Clear old choices
                elements.choices.style.display = 'none';
                elements.nextIndicator.style.display = 'none';
                elements.speaker.textContent = '';
                elements.text.innerHTML = '';

                // --- Update Background ---
                const newBgKey = scene.background;
                const newBgSrc = newBgKey ? resourceLoader.getImageSrc(newBgKey) : null;
                const currentBgStyle = elements.background.style.backgroundImage;
                const currentBgUrlMatch = currentBgStyle.match(/url\(['"]?(.*?)['"]?\)/);
                const currentBgUrl = currentBgUrlMatch ? currentBgUrlMatch[1] : null;

                if (newBgSrc !== currentBgUrl) {
                    // console.log(`Changing background from ${currentBgUrl} to ${newBgSrc}`);
                    gameState.isBackgroundTransitioning = true;
                    elements.background.classList.add('fade'); // Start fade out

                    // Listener for fade-out completion (using { once: true })
                    const handleFadeOutEnd = (event) => {
                        if (event.target === elements.background && event.propertyName === 'opacity') {
                            // Update background image source *after* fade out
                            elements.background.style.backgroundImage = newBgSrc ? `url('${newBgSrc}')` : 'none';
                            elements.background.style.backgroundColor = newBgSrc ? '' : 'var(--main-bg-color)';
                            // Force reflow might be needed in some browsers before removing class
                            void elements.background.offsetWidth;
                            elements.background.classList.remove('fade'); // Start fade in

                            // Listener for fade-in completion (using { once: true })
                            const handleFadeInEnd = (e) => {
                                if (e.target === elements.background && e.propertyName === 'opacity') {
                                    gameState.isBackgroundTransitioning = false;
                                    // console.log("Background transition finished.");
                                    // Resume auto-play or other logic if needed
                                    if (gameState.settings.autoPlay && !gameState.isMenuOpen && !gameState.isShowingChoices && !gameState.isTyping) {
                                        setupAutoPlayTimer();
                                    }
                                }
                            };
                            elements.background.addEventListener('transitionend', handleFadeInEnd, { once: true });
                        }
                    };
                    elements.background.addEventListener('transitionend', handleFadeOutEnd, { once: true });

                    // Safety timeout in case transitionend doesn't fire
                    setTimeout(() => {
                        if (gameState.isBackgroundTransitioning) {
                            console.warn("Background transition timeout. Forcing state update.");
                            // Force remove class and reset state. Listeners are auto-removed via {once: true}.
                            elements.background.classList.remove('fade');
                            elements.background.style.backgroundImage = newBgSrc ? `url('${newBgSrc}')` : 'none';
                            elements.background.style.backgroundColor = newBgSrc ? '' : 'var(--main-bg-color)';
                            gameState.isBackgroundTransitioning = false;
                            if (gameState.settings.autoPlay && !gameState.isMenuOpen && !gameState.isShowingChoices && !gameState.isTyping) {
                                setupAutoPlayTimer();
                            }
                        }
                    }, BACKGROUND_TRANSITION_DURATION_MS + 200); // Slightly longer than CSS duration

                } else {
                    // console.log("Background is the same, skipping transition.");
                    gameState.isBackgroundTransitioning = false; // No transition needed
                    // Need to start dialog display even if background doesn't change
                    displayDialog();
                }

                // --- Update BGM ---
                if (scene.bgm) { audioManager.playBGM(scene.bgm); }
                else { audioManager.stopBGM(); }

                // Play SFX if specified
                if (scene.sfx) { audioManager.playSFX(scene.sfx); }

                // Prefetch resources for potential next scenes (non-blocking)
                prefetchNextScenes(scene);

                // Start displaying dialog only if background isn't transitioning
                // (If it is transitioning, displayDialog will be called by the transition end handler implicitly via state check or timer setup)
                // Correction: displayDialog should always be called unless background fails completely.
                // If background *is* transitioning, text display starts concurrently or after fade-in.
                // Let's call it regardless, text display logic handles its own timing.
                if (!gameState.isBackgroundTransitioning) {
                    displayDialog();
                } else {
                    // If background IS transitioning, call displayDialog immediately anyway.
                    // The text might appear before the background fully fades in, which is acceptable.
                    displayDialog();
                }
            }

            function prefetchNextScenes(currentScene) {
                if (!currentScene?.choices?.length) return;
                const nextSceneIds = [...new Set(currentScene.choices.map(choice => choice.nextScene).filter(Boolean))];
                if (!nextSceneIds.length) return;
                // console.log(`Prefetching assets for potential next scenes: ${nextSceneIds.join(', ')}`);
                nextSceneIds.forEach(sceneId => {
                    const scene = gameContent.scenes.find(s => s.id === sceneId);
                    if (!scene) return;
                    if (scene.background) {
                        const bgSrc = resourceLoader.getImageSrc(scene.background);
                        if (bgSrc) resourceLoader.preloadImage(scene.background, bgSrc).catch(err => console.warn(`Prefetch failed for background ${scene.background}:`, err));
                    }
                    if (scene.bgm) {
                        const bgmSrc = resourceLoader.getAudioSrc(scene.bgm, 'bgm');
                        if (bgmSrc) resourceLoader.preloadSingleAudio(scene.bgm, bgmSrc, 'bgm').catch(err => console.warn(`Prefetch failed for BGM ${scene.bgm}:`, err));
                    }
                });
            }

            function displayDialog() {
                if (gameState.isTitleScreen || gameState.isMenuOpen) return;

                const scene = gameContent.scenes.find(s => s.id === gameState.currentSceneId);
                if (!scene || !scene.dialogs || gameState.currentDialogIndex < 0 || gameState.currentDialogIndex >= scene.dialogs.length) {
                    // End of dialogs or invalid index, try showing choices
                    console.log(`End of dialogs for scene ${gameState.currentSceneId} or invalid index ${gameState.currentDialogIndex}. Checking choices.`);
                    showChoices(scene?.choices);
                    // If showChoices handles empty choices by providing a fallback, we don't need the title screen fallback here.
                    // if (!scene?.choices?.length) {
                    //     showUserMessage("ダイアログエラーが発生しました。タイトルに戻ります。", "error", 6000);
                    //     updateGameState({ isTitleScreen: true });
                    // }
                    return;
                }
                const dialog = scene.dialogs[gameState.currentDialogIndex];
                if (!dialog) {
                    console.error(`Dialog data missing at index ${gameState.currentDialogIndex} for scene ${gameState.currentSceneId}`);
                    showChoices(scene.choices); // Attempt to show choices
                    return;
                }

                // Stop ongoing typing animation/timer
                if (gameState.typingTimeoutId) {
                    if (typeof gameState.typingTimeoutId === 'number' && gameState.typingTimeoutId < 100000) cancelAnimationFrame(gameState.typingTimeoutId);
                    else if (typeof gameState.typingTimeoutId === 'number') clearTimeout(gameState.typingTimeoutId);
                    gameState.typingTimeoutId = null;
                }
                updateGameState({ isTyping: false }); // Ensure state is reset

                elements.speaker.textContent = dialog.speaker || '';
                elements.text.innerHTML = '';
                elements.text.classList.remove('text-fade-in');
                elements.nextIndicator.style.display = 'none';

                if (dialog.sfx) { audioManager.playSFX(dialog.sfx); }
                // Update character graphic if implemented: updateCharacterSprite(dialog.character);

                const textToDisplay = dialog.text || "";
                const effect = dialog.effect;
                const textSpeedMs = TEXT_SPEEDS[gameState.settings.textSpeed] || TEXT_SPEEDS.normal;
                const sanitizedFullText = sanitizeText(textToDisplay);

                // --- Apply Text Effect ---
                if (effect === 'type' && textSpeedMs > 0 && textToDisplay.length > 0) {
                    updateGameState({ isTyping: true });
                    let charIndex = 0;
                    let startTime = performance.now();
                    let rafId;

                    const typeCharacter = (timestamp) => {
                        // Stop if state changed externally OR if typingTimeoutId was cleared (by completeTextAnimation)
                        if (!gameState.isTyping || gameState.typingTimeoutId !== rafId) {
                            cancelAnimationFrame(rafId);
                            return;
                        }
                        const elapsed = timestamp - startTime;
                        const targetIndex = Math.min(Math.floor(elapsed / textSpeedMs), textToDisplay.length);
                        if (targetIndex > charIndex) {
                            elements.text.innerHTML = sanitizeText(textToDisplay.substring(0, targetIndex));
                            optimizedScroll(elements.text);
                            charIndex = targetIndex;
                        }
                        if (charIndex < textToDisplay.length) {
                            rafId = requestAnimationFrame(typeCharacter);
                            gameState.typingTimeoutId = rafId;
                        } else {
                            finishDialogDisplay();
                        }
                    };
                    rafId = requestAnimationFrame(typeCharacter);
                    gameState.typingTimeoutId = rafId;

                } else if (effect === 'fade') {
                    elements.text.innerHTML = sanitizedFullText;
                    elements.text.classList.add('text-fade-in');
                    updateGameState({ isTyping: true });
                    const timeoutId = setTimeout(() => {
                        // Check if this specific timeout is still the active one before finishing
                        if (gameState.typingTimeoutId === timeoutId) {
                            finishDialogDisplay();
                        }
                    }, TRANSITION_DURATION_MS);
                    gameState.typingTimeoutId = timeoutId;
                } else {
                    elements.text.innerHTML = sanitizedFullText;
                    finishDialogDisplay();
                }
            }


            function finishDialogDisplay() {
                // Check if currently typing before clearing state
                const wasTyping = gameState.isTyping;
                gameState.typingTimeoutId = null; // Clear ID regardless

                if (wasTyping) {
                    // Update state only if still in a valid game context
                    if (!gameState.isTitleScreen && !gameState.isMenuOpen) {
                        updateGameState({ isTyping: false }); // Triggers indicator/auto-play via side effects
                        optimizedScroll(elements.text); // Scroll one last time
                    } else {
                        // If title/menu opened during typing, just reset state flags
                        gameState.isTyping = false;
                        elements.nextIndicator.style.display = 'none';
                    }
                }
            }

            function completeTextAnimation() {
                if (!gameState.isTyping) return;
                // console.log("Completing text animation.");

                if (gameState.typingTimeoutId) {
                    if (typeof gameState.typingTimeoutId === 'number' && gameState.typingTimeoutId < 100000) cancelAnimationFrame(gameState.typingTimeoutId);
                    else if (typeof gameState.typingTimeoutId === 'number') clearTimeout(gameState.typingTimeoutId);
                    // Don't nullify typingTimeoutId here, let finishDialogDisplay handle it after setting text
                }

                elements.text.classList.remove('text-fade-in');

                const scene = gameContent.scenes.find(s => s.id === gameState.currentSceneId);
                if (scene && scene.dialogs && scene.dialogs[gameState.currentDialogIndex]) {
                    const dialog = scene.dialogs[gameState.currentDialogIndex];
                    elements.text.innerHTML = sanitizeText(dialog.text || "");
                    optimizedScroll(elements.text);
                }

                // Mark display as finished (triggers indicator/auto-play)
                finishDialogDisplay();
            }


            function advanceDialog() {
                clearAutoPlayTimer();
                const scene = gameContent.scenes.find(s => s.id === gameState.currentSceneId);
                if (!scene) {
                    console.error("Cannot advance dialog: Current scene not found.");
                    updateGameState({ isTitleScreen: true });
                    return;
                }

                const nextDialogIndex = gameState.currentDialogIndex + 1;

                if (!scene.dialogs || nextDialogIndex >= scene.dialogs.length) {
                    // End of dialogs, check for choices
                    updateGameState({ currentDialogIndex: nextDialogIndex }); // Store index past last dialog
                    showChoices(scene.choices); // showChoices handles empty/invalid choices
                } else {
                    // More dialogs exist, advance index and display
                    updateGameState({ currentDialogIndex: nextDialogIndex });
                    displayDialog();
                }
            }

            // REFACTORED: showChoices using button reuse and accessibility improvements
            function showChoices(choicesData) {
                // Default fallback if choicesData is invalid or empty
                if (!choicesData || !Array.isArray(choicesData) || choicesData.length === 0) {
                    console.warn("showChoices called with invalid or empty data. Adding fallback to title.");
                    choicesData = [{ text: "タイトルに戻る", nextScene: TITLE_SCENE_ID }];
                }

                const container = elements.choices;
                const existingButtons = container.querySelectorAll('.choice');
                let buttonIndex = 0;

                choicesData.forEach(choiceData => {
                    // Basic validation for each choice item
                    if (!choiceData || typeof choiceData.text !== 'string' || typeof choiceData.nextScene !== 'string') {
                        console.warn("Skipping invalid choice data item:", choiceData);
                        return; // Skip this invalid choice
                    }

                    let choiceButton;
                    // Try to reuse existing button
                    if (buttonIndex < existingButtons.length) {
                        choiceButton = existingButtons[buttonIndex];
                    } else {
                        // Create new button if needed
                        choiceButton = document.createElement('button');
                        choiceButton.className = 'choice';
                        choiceButton.setAttribute('role', 'button'); // Accessibility
                        container.appendChild(choiceButton); // Append new button
                    }

                    // Update button content and action
                    choiceButton.textContent = choiceData.text;
                    choiceButton.setAttribute('aria-label', `選択肢: ${choiceData.text}`); // Accessibility
                    choiceButton.style.display = 'block'; // Make it visible

                    // Update onclick handler - Use a self-removing listener or clone/replace
                    // Cloning is simpler to ensure old listeners are gone.
                    const newButton = choiceButton.cloneNode(true); // Clone to remove listeners easily
                    newButton.onclick = () => selectChoice(choiceData.nextScene);
                    choiceButton.parentNode.replaceChild(newButton, choiceButton); // Replace in DOM

                    buttonIndex++;
                });

                // Hide any remaining unused existing buttons
                for (let i = buttonIndex; i < existingButtons.length; i++) {
                    existingButtons[i].style.display = 'none';
                }

                // Show the choices container and update game state
                container.style.display = 'flex';
                elements.nextIndicator.style.display = 'none'; // Hide next indicator
                updateGameState({ isShowingChoices: true });
                clearAutoPlayTimer(); // Stop auto-play when choices appear
            }


            function selectChoice(nextSceneId) {
                // console.log(`Choice selected, next scene ID: ${nextSceneId}`);
                audioManager.playSFX('select');

                // Special case: "title" scene ID always returns to title screen
                if (nextSceneId === TITLE_SCENE_ID) { // Use constant
                    updateGameState({ isTitleScreen: true });
                    // audioManager.stopBGM(); // Optional: Stop BGM when returning to title
                    return;
                }

                // Special case: "load" - unlikely in normal choices now, but handle defensively
                if (nextSceneId === "load") {
                    console.warn("Choice 'load' selected in-game, likely an error. Opening menu.");
                    openMenu();
                    return;
                }

                const sceneExists = gameContent.scenes.find(s => s.id === nextSceneId);
                if (sceneExists) {
                    elements.choices.style.display = 'none';
                    updateGameState({ isShowingChoices: false });
                    loadScene(nextSceneId);
                } else {
                    console.error(`Choice leads to non-existent scene: ${nextSceneId}.`);
                    showUserMessage(`エラー：次のシーン (${nextSceneId}) が見つかりません。タイトルに戻ります。`, "error", 6000);
                    elements.choices.style.display = 'none';
                    updateGameState({ isShowingChoices: false, isTitleScreen: true }); // Go to title on error
                }
            }

            // --- Title Screen Logic ---
            function showTitleScreen() {
                // console.log("Showing title screen");
                const titleScene = gameContent.scenes.find(s => s.id === TITLE_SCENE_ID);
                const titleBgKey = titleScene?.background;
                const titleBgSrc = titleBgKey ? resourceLoader.getImageSrc(titleBgKey) : null;
                elements.titleScreen.style.backgroundImage = titleBgSrc ? `url('${titleBgSrc}')` : 'none';
                elements.titleScreen.style.backgroundColor = titleBgSrc ? '' : 'var(--main-bg-color)';

                // Ensure game elements are hidden/reset
                elements.game.classList.remove('visible');
                elements.menu.classList.remove('visible');
                elements.menu.style.display = 'none';
                // menuButton display is handled by #game.visible CSS rule
                elements.choices.style.display = 'none';
                // dialogBox visibility is handled by #game:not(.visible) CSS rule

                audioManager.stopBGM();
                // Optional: Play title screen specific BGM (will play after first interaction)
                // const titleBgmKey = gameContent.assets.bgm?.title ? 'title' : null;
                // if (titleBgmKey) audioManager.playBGM(titleBgmKey);

                cleanupScene(); // Clear game timers/transitions

                // Show title screen elements
                elements.titleScreen.classList.add('visible');
                hideTitleLoadSlots(); // Ensure load slots are hidden initially

                if (!elements.loading.classList.contains('hidden')) {
                    elements.loading.classList.add('hidden');
                    elements.loading.style.pointerEvents = 'none';
                }

                // Update game state - must happen *after* UI changes for consistency
                updateGameState({
                    isTitleScreen: true,
                    isMenuOpen: false,
                    isShowingChoices: false,
                    isTyping: false,
                    currentSceneId: null,
                    currentDialogIndex: 0
                });
            }

            function hideTitleScreen() {
                // console.log("Hiding title screen");
                elements.titleScreen.classList.remove('visible');
                elements.game.classList.add('visible'); // Make game container visible
                // Menu button and Dialog box visibility are handled by CSS based on #game.visible
                // State update (isTitleScreen: false) happens in the calling function (startGame, load)
            }

            function startGame() {
                // console.log("Starting new game...");
                audioManager.ensureAudioResumed(); // Ensure audio ready on the interaction that starts the game
                const firstGameScene = gameContent.scenes.find(s => s.id !== TITLE_SCENE_ID);
                const firstSceneId = firstGameScene?.id;

                if (!firstSceneId) {
                    console.error("No valid starting scene found (excluding title)! Check gameContent.scenes.");
                    showUserMessage("エラー：開始シーンが見つかりません。", "error");
                    return;
                }

                updateGameState({ isTitleScreen: false }); // This triggers hideTitleScreen via state update side effect
                loadScene(firstSceneId);
            }

            function showTitleLoadSlots() {
                updateTitleLoadSlots(); // Populate/update slots before showing
                elements.titleLoadSlotsContainer.style.display = 'block';
                // Hide main title buttons
                elements.startButton.style.display = 'none';
                elements.loadButton.style.display = 'none';
                elements.quitButton.style.display = 'none';
            }

            function hideTitleLoadSlots() {
                elements.titleLoadSlotsContainer.style.display = 'none';
                // Show main title buttons again
                elements.startButton.style.display = 'block';
                elements.loadButton.style.display = 'block';
                elements.quitButton.style.display = 'block';
            }

            function updateTitleLoadSlots() {
                const saves = saveManager.getAllSaveData();
                const container = elements.titleLoadSlotsContainer;

                while (container.firstChild && !container.firstChild.isSameNode(elements.titleLoadBackButton)) {
                    container.removeChild(container.firstChild);
                }
                const fragment = document.createDocumentFragment();
                saves.forEach(saveData => {
                    const slotEl = document.createElement('div');
                    updateSingleSlotUI(slotEl, saveData, 'load', (slot, action, isEmpty) => {
                        // Click handler for TITLE SCREEN load slots
                        if (!isEmpty) {
                            if (confirm(`スロット ${slot} からロードしますか？`)) {
                                // On successful load, hide title screen
                                audioManager.ensureAudioResumed(); // Ensure audio is ready for loaded game
                                saveManager.load(slot, () => {
                                    // The load function calls loadScene, which sets isTitleScreen: false
                                    // No need to explicitly call hideTitleScreen here.
                                    // updateGameState({ isTitleScreen: false }); // This is handled by loadScene/updateGameState
                                });
                            }
                        }
                    });
                    fragment.appendChild(slotEl);
                });
                container.insertBefore(fragment, elements.titleLoadBackButton);
                if (!container.contains(elements.titleLoadBackButton)) {
                    container.appendChild(elements.titleLoadBackButton);
                }
            }

            // --- Generic Slot UI Update Functions ---

            function updateSlotsContainer(container, actionType, onClickCallback) {
                if (!container) { console.warn(`Slot container for action ${actionType} not found.`); return; }
                const saves = saveManager.getAllSaveData();
                const existingSlots = container.querySelectorAll('.slot');
                existingSlots.forEach(slot => slot.remove());
                const fragment = document.createDocumentFragment();
                saves.forEach(saveData => {
                    const slotEl = document.createElement('div');
                    updateSingleSlotUI(slotEl, saveData, actionType, onClickCallback);
                    fragment.appendChild(slotEl);
                });
                container.appendChild(fragment);
            }

            function updateSingleSlotUI(slotEl, saveData, actionType, onClickCallback) {
                slotEl.innerHTML = ''; // Clear previous content
                slotEl.className = 'slot';
                slotEl.dataset.slot = saveData.slot;
                slotEl.dataset.action = actionType;

                const nameEl = document.createElement('span');
                nameEl.className = 'slot-name';
                nameEl.textContent = `スロット ${saveData.slot}`;
                slotEl.appendChild(nameEl);

                const infoEl = document.createElement('span');
                infoEl.className = 'slot-info';
                slotEl.appendChild(infoEl);

                slotEl.onclick = null; // Clear previous handler

                if (saveData.isEmpty) {
                    slotEl.classList.add('empty');
                    infoEl.textContent = (actionType === 'save') ? '空きスロット' : 'データなし';
                    if (actionType === 'save') {
                        slotEl.onclick = () => onClickCallback(saveData.slot, actionType, saveData.isEmpty);
                    } else {
                        slotEl.style.cursor = 'default';
                    }
                } else {
                    const date = new Date(saveData.timestamp);
                    const sceneInfo = gameContent.scenes.find(s => s.id === saveData.sceneId);
                    // Try to get a more descriptive scene name (first line of dialog, chapter name, or fallback)
                    let sceneLabel = sceneInfo?.dialogs?.[0]?.text?.split('：')[0]; // Get "第X章" or first part
                    if (!sceneLabel || sceneLabel.length > 20) { // If too long or missing, use ID
                        sceneLabel = sceneInfo?.id?.replace(/_/g, ' ') || '不明';
                    }
                    // Truncate if still too long
                    sceneLabel = sceneLabel.length > 15 ? sceneLabel.substring(0, 12) + '...' : sceneLabel;

                    infoEl.textContent = `${sceneLabel} - ${date.toLocaleString('ja-JP', { dateStyle: 'short', timeStyle: 'short' })}`;
                    slotEl.onclick = () => onClickCallback(saveData.slot, actionType, saveData.isEmpty);
                }
            }

            function updateSlotUI(slotNumber) {
                const saveData = saveManager.getSaveData(slotNumber);
                const saveSlotEl = elements.saveSlotsContainer?.querySelector(`.slot[data-slot="${slotNumber}"]`);
                if (saveSlotEl) {
                    updateSingleSlotUI(saveSlotEl, saveData, 'save', (slot, action, isEmpty) => {
                        const confirmMsg = isEmpty ? `スロット ${slot} にセーブしますか？` : `スロット ${slot} のデータを上書きしますか？`;
                        if (confirm(confirmMsg)) {
                            saveManager.save(slot);
                        }
                    });
                }
                const loadSlotEl = elements.loadSlotsContainer?.querySelector(`.slot[data-slot="${slotNumber}"]`);
                if (loadSlotEl) {
                    updateSingleSlotUI(loadSlotEl, saveData, 'load', (slot, action, isEmpty) => {
                        if (!isEmpty) {
                            if (confirm(`スロット ${slot} からロードしますか？`)) {
                                audioManager.ensureAudioResumed(); // Ensure audio ready
                                saveManager.load(slot, closeMenu);
                            }
                        }
                    });
                }
                // Title load slots are updated en masse via updateTitleLoadSlots when shown
            }


            // --- Menu Logic ---
            function toggleMenu() {
                if (gameState.isMenuOpen) {
                    closeMenu();
                } else {
                    openMenu();
                }
            }

            function openMenu() {
                if (gameState.isTitleScreen) return; // Cannot open menu on title screen
                if (gameState.isMenuOpen) return; // Already open

                clearAutoPlayTimer();
                updateMenuUI(); // Update slots *before* showing

                updateGameState({ isMenuOpen: true }); // Update state first
                elements.menu.style.display = 'flex'; // Make it visible for transition
                requestAnimationFrame(() => { // Ensure display:flex is applied before adding class
                    elements.menu.classList.add('visible'); // Trigger opacity transition
                });
            }

            function closeMenu() {
                if (!gameState.isMenuOpen) return; // Already closed

                updateGameState({ isMenuOpen: false }); // Update state first
                elements.menu.classList.remove('visible'); // Start fade out transition

                // Hide the menu element completely after the transition ends using { once: true }
                const handleTransitionEnd = (event) => {
                    if (event.target === elements.menu && event.propertyName === 'opacity') {
                        if (!gameState.isMenuOpen) { // Double check state in case reopened
                            elements.menu.style.display = 'none';
                        }
                    }
                };
                elements.menu.addEventListener('transitionend', handleTransitionEnd, { once: true });

                // Resume auto-play if applicable
                if (gameState.settings.autoPlay && !gameState.isTyping && !gameState.isShowingChoices && !gameState.isBackgroundTransitioning && !gameState.isTitleScreen) {
                    setupAutoPlayTimer();
                }
            }

            function updateMenuUI() {
                // Update Save Slots
                updateSlotsContainer(elements.saveSlotsContainer, 'save', (slot, action, isEmpty) => {
                    const confirmMsg = isEmpty ? `スロット ${slot} にセーブしますか？` : `スロット ${slot} のデータを上書きしますか？`;
                    if (confirm(confirmMsg)) {
                        saveManager.save(slot);
                    }
                });
                // Update Load Slots
                updateSlotsContainer(elements.loadSlotsContainer, 'load', (slot, action, isEmpty) => {
                    if (!isEmpty) {
                        if (confirm(`スロット ${slot} からロードしますか？`)) {
                            audioManager.ensureAudioResumed(); // Ensure audio ready for loaded game
                            saveManager.load(slot, closeMenu);
                        }
                    }
                });
                updateSettingsUI();
            }

            // --- Settings Logic ---
            function setupSettingsListeners() {
                elements.settingsSection.addEventListener('click', (e) => {
                    const target = e.target.closest('.setting-btn');
                    if (!target) return;
                    const settingValueDiv = target.closest('.setting-value');
                    if (!settingValueDiv) return;
                    const id = settingValueDiv.id;
                    let newSettings = { ...gameState.settings };
                    try {
                        if (id === 'text-speed-settings') {
                            const speed = target.dataset.speed;
                            if (speed && TEXT_SPEEDS[speed] !== undefined) newSettings.textSpeed = speed;
                        } else if (id === 'bgm-volume-settings') {
                            const volume = parseFloat(target.dataset.volume);
                            if (!isNaN(volume) && volume >= 0 && volume <= 1) newSettings.bgmVolume = volume;
                        } else if (id === 'sfx-volume-settings') {
                            const volume = parseFloat(target.dataset.volume);
                            if (!isNaN(volume) && volume >= 0 && volume <= 1) {
                                newSettings.sfxVolume = volume;
                                // Update volume immediately *before* playing test sound
                                audioManager.updateVolume();
                                // Use setTimeout to ensure state update/volume apply before playing sound
                                setTimeout(() => audioManager.playSFX('select'), 50);
                            }
                        } else if (id === 'auto-play-settings') {
                            newSettings.autoPlay = target.dataset.auto === 'on';
                        }
                        // Update game state and persist settings
                        updateGameState({ settings: newSettings });
                        updateSettingsUI(); // Update button visuals
                        if (id !== 'sfx-volume-settings') { // SFX volume is updated inside the if block
                            audioManager.updateVolume(); // Apply other volume changes
                        }
                        saveSettings(); // Save to localStorage
                    } catch (error) {
                        console.error("Error processing setting change:", error);
                        showUserMessage("設定の適用中にエラーが発生しました。", "error");
                    }
                });
            }

            function updateSettingsUI() {
                try {
                    const { textSpeed, bgmVolume, sfxVolume, autoPlay } = gameState.settings;
                    elements.textSpeedSettings?.querySelectorAll('.setting-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.speed === textSpeed));
                    elements.bgmVolumeSettings?.querySelectorAll('.setting-btn').forEach(btn => btn.classList.toggle('active', parseFloat(btn.dataset.volume) === bgmVolume));
                    elements.sfxVolumeSettings?.querySelectorAll('.setting-btn').forEach(btn => btn.classList.toggle('active', parseFloat(btn.dataset.volume) === sfxVolume));
                    elements.autoPlaySettings?.querySelectorAll('.setting-btn').forEach(btn => btn.classList.toggle('active', (btn.dataset.auto === 'on') === autoPlay));
                } catch (error) {
                    console.error("Error updating settings UI:", error);
                }
            }

            // --- Auto Play Logic ---
            function setupAutoPlayTimer() {
                clearAutoPlayTimer();
                if (gameState.settings.autoPlay &&
                    !gameState.isMenuOpen &&
                    !gameState.isTyping &&
                    !gameState.isShowingChoices &&
                    !gameState.isBackgroundTransitioning &&
                    !gameState.isTitleScreen) {
                    gameState.autoPlayTimerId = setTimeout(() => {
                        // Double-check state before advancing
                        if (gameState.settings.autoPlay && !gameState.isMenuOpen && !gameState.isTyping &&
                            !gameState.isShowingChoices && !gameState.isBackgroundTransitioning && !gameState.isTitleScreen) {
                            // console.log("Auto-playing...");
                            handleInteraction(true); // Pass flag indicating auto-play origin
                        }
                        gameState.autoPlayTimerId = null;
                    }, AUTO_PLAY_DELAY);
                }
            }

            function clearAutoPlayTimer() {
                if (gameState.autoPlayTimerId) {
                    clearTimeout(gameState.autoPlayTimerId);
                    gameState.autoPlayTimerId = null;
                }
            }

            // --- Input Handling ---
            function setupTouchListeners() {
                let touchStartY = 0;
                let isSwiping = false;
                let tapTimeoutId = null;
                const SWIPE_THRESHOLD = 50;
                const TAP_THRESHOLD = 10; // Max movement tolerance for a tap
                const DOUBLE_TAP_DELAY = 300; // ms for double tap detection (optional)

                elements.dialogBox.addEventListener('touchstart', (e) => {
                    if (gameState.isTitleScreen || gameState.isMenuOpen || gameState.isShowingChoices) return;
                    if (e.touches.length > 1) { isSwiping = true; return; }
                    touchStartY = e.touches[0].clientY;
                    isSwiping = false;
                    // Clear previous tap timeout if any (for double tap logic, optional)
                    // if (tapTimeoutId) clearTimeout(tapTimeoutId);
                }, { passive: true });

                elements.dialogBox.addEventListener('touchmove', (e) => {
                    if (gameState.isTitleScreen || gameState.isMenuOpen || gameState.isShowingChoices || e.touches.length > 1) return;
                    if (Math.abs(e.touches[0].clientY - touchStartY) > TAP_THRESHOLD) {
                        isSwiping = true;
                    }
                }, { passive: true });

                elements.dialogBox.addEventListener('touchend', (e) => {
                    if (gameState.isTitleScreen || gameState.isMenuOpen || gameState.isShowingChoices || e.changedTouches.length > 1) return;
                    if (e.touches.length > 0) return; // Ignore if other fingers still down

                    const touchEndY = e.changedTouches[0].clientY;
                    const swipeDistance = touchStartY - touchEndY;

                    if (isSwiping) {
                        if (swipeDistance > SWIPE_THRESHOLD) { // Swipe Up
                            // console.log("Swipe up detected, toggling menu.");
                            if (!gameState.isMenuOpen) openMenu(); // Only open on swipe up
                        }
                        // else if (swipeDistance < -SWIPE_THRESHOLD) { // Swipe Down (optional action) }
                    } else { // Considered a Tap
                        // console.log("Tap detected on dialog box.");
                        // If implementing double tap to skip:
                        // if (tapTimeoutId) { // Second tap detected quickly
                        //    clearTimeout(tapTimeoutId);
                        //    tapTimeoutId = null;
                        //    // Handle skip action (e.g., skip scene or fast forward)
                        // } else {
                        //    tapTimeoutId = setTimeout(() => { tapTimeoutId = null; }, DOUBLE_TAP_DELAY);
                        //    handleInteraction(); // Handle single tap (advance/skip text)
                        // }
                        handleInteraction(); // Handle single tap
                        e.preventDefault(); // Prevent click event after touchend
                    }
                    isSwiping = false;
                }, { passive: false }); // Need non-passive for preventDefault
            }

            // Central handler for user interaction (click, tap, space, enter, auto-play timer)
            function handleInteraction(isAutoPlay = false) {
                // Ensure audio context is ready (critical on first interaction)
                // Do this *before* state checks to unlock audio even if interaction is ignored
                audioManager.ensureAudioResumed();

                // If triggered by auto-play, don't proceed if choices are shown
                if (isAutoPlay && gameState.isShowingChoices) {
                    // console.log("Auto-play ignored: Choices are visible.");
                    return;
                }

                // Check if interaction should be ignored based on game state
                if (gameState.isTitleScreen || gameState.isMenuOpen || gameState.isBackgroundTransitioning) {
                    // console.log("Interaction ignored: Invalid state (Title, Menu, or BG Transition).");
                    return;
                }
                // If choices are showing, interaction should be handled by choice buttons, not here.
                if (gameState.isShowingChoices && !isAutoPlay) {
                    // console.log("Interaction ignored: Choices are visible.");
                    return;
                }


                // If text is currently typing, complete the animation
                if (gameState.isTyping) {
                    completeTextAnimation();
                }
                // Otherwise (text is fully displayed), advance the dialog
                else {
                    advanceDialog();
                }
            }

            function setupEventListeners() {
                // console.log("Setting up main event listeners");

                // --- Title Screen Buttons ---
                elements.startButton.addEventListener('click', startGame);
                elements.loadButton.addEventListener('click', showTitleLoadSlots);
                elements.quitButton.addEventListener('click', () => {
                    showUserMessage("ゲームを終了します。このタブまたはウィンドウを閉じてください。", "info", 6000);
                    // Note: window.close() rarely works for non-popup windows.
                });
                elements.titleLoadBackButton.addEventListener('click', hideTitleLoadSlots);

                // --- Game Interaction (Dialog Box Click) ---
                // Use click for mouse, touchend handles taps
                elements.dialogBox.addEventListener('click', (e) => {
                    // Ignore synthesized clicks from touchend handled above, or invalid states
                    if (e.detail > 0 && !gameState.isTitleScreen && !gameState.isMenuOpen && !gameState.isShowingChoices && !gameState.isBackgroundTransitioning) {
                        // console.log("Click detected on dialog box.");
                        handleInteraction();
                    }
                });

                // --- Keyboard Interaction ---
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;
                    if (e.metaKey || e.ctrlKey || e.altKey) return; // Ignore modified keys

                    if (gameState.isTitleScreen) {
                        if (e.code === 'Enter' || e.code === 'NumpadEnter' || e.code === 'Space') {
                            e.preventDefault();
                            // Focus the start button and click it, or directly start
                            elements.startButton.click();
                        } else if (e.code === 'ArrowDown' || e.code === 'ArrowUp') {
                            e.preventDefault();
                            // Basic focus navigation between title buttons
                            const buttons = [elements.startButton, elements.loadButton, elements.quitButton].filter(btn => btn.style.display !== 'none');
                            const currentFocus = document.activeElement;
                            let currentIndex = buttons.findIndex(btn => btn === currentFocus);
                            if (currentIndex === -1) currentIndex = 0; // Start from first if none focused
                            const nextIndex = e.code === 'ArrowDown'
                                ? (currentIndex + 1) % buttons.length
                                : (currentIndex - 1 + buttons.length) % buttons.length;
                            buttons[nextIndex]?.focus();
                        }
                        return;
                    }

                    if (gameState.isMenuOpen) {
                        if (e.code === 'Escape') { e.preventDefault(); closeMenu(); }
                        // Add basic menu navigation (optional)
                        return;
                    }

                    // --- In-Game Keys (Menu closed, not Title) ---
                    if (e.code === 'Space' || e.code === 'Enter' || e.code === 'NumpadEnter') {
                        e.preventDefault();
                        handleInteraction(); // Advance dialog or skip typing
                    }
                    if (e.code === 'Escape' || e.code === 'KeyM') {
                        e.preventDefault();
                        toggleMenu();
                    }
                });

                // --- Menu Buttons ---
                elements.menuButton.addEventListener('click', toggleMenu);
                elements.backToGame.addEventListener('click', closeMenu);

                // --- Global listener for Audio Context Resumption (already handled by handleInteraction) ---
                // No longer need the global body listeners as ensureAudioResumed is called
                // within the interaction handlers (click, keydown, touchend) via handleInteraction.
            }

            // --- Game Initialization ---
            async function init() {
                console.log("Initializing game...");
                try {
                    // 1. Load Settings
                    try {
                        const savedSettings = localStorage.getItem('gameSettings');
                        if (savedSettings) {
                            const parsedSettings = JSON.parse(savedSettings);
                            if (typeof parsedSettings === 'object' && parsedSettings !== null) {
                                gameState.settings = { ...gameState.settings, ...parsedSettings };
                            } else {
                                console.warn("Invalid settings format found in localStorage.");
                            }
                        }
                    } catch (e) {
                        console.warn("Failed to load/parse settings, using defaults:", e);
                        // Optionally clear corrupted settings data
                        try { localStorage.removeItem('gameSettings'); } catch (removeError) {/* ignore */ }
                    }

                    // 2. Initialize Save Cache
                    saveManager.initCache();

                    // 3. Initialize Audio Manager (applies loaded settings)
                    await audioManager.init();

                    // 4. Setup UI Listeners and Initial State
                    setupEventListeners();
                    setupSettingsListeners();
                    setupTouchListeners();
                    updateSettingsUI(); // Reflect loaded/default settings

                    // 5. Show Title Screen (which hides loading screen)
                    showTitleScreen();

                    // 6. Start Background Resource Preloading
                    resourceLoader.preloadResources().then(success => {
                        if (success) {
                            // console.log("Background resource preloading complete.");
                        } else {
                            console.warn("Background resource preloading encountered errors.");
                            // Optionally inform user about loading issues
                            // showUserMessage("一部リソースの読み込みに失敗しました。表示が乱れる可能性があります。", "warning", 5000);
                        }
                    }).catch(error => {
                        console.error("Error during background resource preloading:", error);
                    });

                } catch (error) {
                    console.error("Critical game initialization error:", error);
                    if (elements.loading) elements.loading.classList.add('hidden');
                    document.body.innerHTML = `<div style="color: red; padding: 20px; font-family: sans-serif;">ゲームの初期化中に致命的なエラーが発生しました。<br>詳細: ${sanitizeText(error.message)}<br>ページを再読み込みするか、開発者にご連絡ください。</div>`;
                }
            }

            // --- Start the game initialization ---
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }

        })(); // IIFE End
    </script>
</body>

</html>
